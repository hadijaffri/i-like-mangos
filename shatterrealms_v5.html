<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShatterRealms - Realism Edition</title>
    <!-- Vercel Analytics -->
    <script defer src="https://va.vercel-scripts.com/v1/script.js"></script>
    <!-- Stripe.js -->
    <script src="https://js.stripe.com/v3/"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        body {
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #hud {
            position: fixed;
            bottom: 100px;
            left: 15px;
            pointer-events: none;
            z-index: 100;
        }
        
        .bar-container {
            width: 180px;
            height: 18px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 9px;
            margin-bottom: 5px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill { height: 100%; transition: width 0.3s ease; }
        #healthBar .bar-fill { background: linear-gradient(90deg, #8b0000, #ff3333); }
        #energyBar .bar-fill { background: linear-gradient(90deg, #003366, #0088ff); }

        .ability-icon {
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #666;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            position: relative;
            transition: all 0.2s ease;
        }

        .ability-icon.ready {
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .ability-icon.active {
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.3);
            box-shadow: 0 0 12px rgba(255, 255, 0, 0.7);
        }

        .ability-icon.cooldown {
            border-color: #ff4444;
            opacity: 0.6;
        }

        .ability-icon::after {
            content: attr(data-key);
            position: absolute;
            bottom: -12px;
            font-size: 8px;
            color: #aaa;
        }

        .bar-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
        }
        
        .bar-icon {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
        }
        
        #coinsDisplay {
            position: fixed;
            top: 15px;
            right: 130px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid gold;
            border-radius: 15px;
            padding: 5px 12px;
            color: gold;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }
        
        #statsPanel {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px;
            color: white;
            font-size: 10px;
            z-index: 100;
        }
        
        .stat-label { color: #aaa; font-size: 8px; }
        .stat-value { color: #fff; font-weight: bold; font-size: 12px; }
        
        #hotbar {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            z-index: 110;
            pointer-events: auto;
        }
        
        .hotbar-slot {
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        
        .hotbar-slot.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 8px rgba(255, 200, 0, 0.5);
        }

        .hotbar-slot[draggable="true"] {
            cursor: grab;
        }

        .hotbar-slot[draggable="true"]:active {
            cursor: grabbing;
        }

        .hotbar-slot.drag-over {
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
        }

        .hotbar-slot .item-icon { font-size: 18px; }
        .hotbar-slot .item-name { font-size: 6px; color: #aaa; }
        .hotbar-slot .slot-key {
            position: absolute;
            top: 1px; left: 3px;
            font-size: 8px;
            color: #888;
        }
        
        .hotbar-slot .cooldown-overlay {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 10px;
            text-align: center;
            display: none;
        }
        
        #minimap {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 90px;
            height: 90px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            overflow: hidden;
            z-index: 100;
        }
        
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            width: 16px; height: 16px;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }
        
        #crosshair::before { width: 12px; height: 2px; top: 7px; left: 2px; }
        #crosshair::after { width: 2px; height: 12px; top: 2px; left: 7px; }
        
        #waveAnnounce {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 200;
            pointer-events: none;
        }
        
        /* Chat System - positioned on right side to not block health */
        #chatContainer {
            position: fixed;
            bottom: 20px;
            right: 10px;
            width: 320px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 8px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            display: none;
            z-index: 100;
        }

        #chatMessages {
            max-height: 140px;
            overflow-y: auto;
            margin-bottom: 8px;
        }

        .chat-message {
            padding: 3px 6px;
            margin: 2px 0;
            border-radius: 4px;
            word-wrap: break-word;
        }

        .chat-message.player {
            background: rgba(100, 150, 255, 0.3);
        }

        .chat-message.system {
            background: rgba(255, 200, 0, 0.3);
            font-style: italic;
        }

        .chat-message.filtered {
            background: rgba(255, 50, 50, 0.3);
        }

        .chat-message .name {
            font-weight: bold;
            color: #88ccff;
        }

        .chat-message .text {
            color: #ffffff;
        }

        .chat-message .filtered-text {
            color: #888;
            filter: blur(3px);
        }

        #chatInputArea {
            display: flex;
            gap: 5px;
        }

        #chatInput {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 12px;
        }

        #chatInput:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
        }

        #chatSend {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: #4488ff;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        #chatSend:hover {
            background: #5599ff;
        }

        #bossHealth {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            display: none;
            z-index: 100;
        }
        
        #bossName {
            text-align: center;
            color: #ff4444;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        #bossBarContainer {
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4444;
            border-radius: 6px;
            overflow: hidden;
        }
        
        #bossFill {
            height: 100%;
            background: linear-gradient(90deg, #660000, #ff0000);
            width: 100%;
            transition: width 0.3s;
        }
        
        #menu {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #menu h1 {
            font-size: 42px;
            color: #fff;
            text-shadow: 0 0 40px rgba(100, 200, 255, 0.8);
            margin-bottom: 5px;
        }
        
        #menu h2 {
            font-size: 14px;
            color: #88ccff;
            margin-bottom: 20px;
            font-weight: normal;
        }
        
        .menu-btn {
            padding: 10px 30px;
            font-size: 14px;
            background: linear-gradient(135deg, #4a00e0, #8e2de2);
            border: none;
            border-radius: 18px;
            color: white;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .menu-btn:hover { transform: scale(1.05); }
        .menu-btn.shop-btn { background: linear-gradient(135deg, #f39c12, #e74c3c); }
        .menu-btn.settings-btn { background: linear-gradient(135deg, #27ae60, #2ecc71); }
        .menu-btn.quit-btn { background: linear-gradient(135deg, #636e72, #2d3436); }
        
        .panel {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.98);
            border: 3px solid #8e2de2;
            border-radius: 15px;
            z-index: 1001;
            width: 90%;
            max-width: 450px;
            max-height: 75vh;
            overflow: hidden;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .panel-header h2 { color: gold; margin: 0; font-size: 18px; }
        
        .panel-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
            -webkit-overflow-scrolling: touch;
        }
        
        .close-btn {
            font-size: 22px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px 10px;
        }
        
        #shopPanel { border-color: #f39c12; }
        #shopPanel .panel-header h2 { color: #f39c12; }
        
        .shop-item {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            gap: 8px;
        }
        
        .shop-item-icon { font-size: 24px; }
        .shop-item-info { flex: 1; }
        .shop-item-name { color: white; font-weight: bold; font-size: 12px; }
        .shop-item-desc { color: #888; font-size: 10px; }
        .shop-item-price { color: gold; font-weight: bold; font-size: 12px; margin-right: 8px; }
        
        .shop-buy-btn {
            padding: 5px 12px;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 11px;
        }
        
        .shop-buy-btn:disabled { background: #444; cursor: not-allowed; }

        /* Coin Shop Styles */
        .coin-shop-section {
            border-top: 2px solid rgba(255, 215, 0, 0.3);
            margin-top: 15px;
            padding-top: 15px;
        }
        .coin-shop-title {
            color: gold;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        .coin-packs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .coin-pack {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.1));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .coin-pack:hover {
            transform: scale(1.05);
            border-color: gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        .coin-pack.popular {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 215, 0, 0.1));
        }
        .coin-pack.popular::before {
            content: '‚≠ê BEST VALUE';
            display: block;
            color: #ff6b6b;
            font-size: 8px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .coin-pack-amount {
            font-size: 24px;
            color: gold;
            font-weight: bold;
        }
        .coin-pack-bonus {
            font-size: 10px;
            color: #4caf50;
            margin-top: 2px;
        }
        .coin-pack-price {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin-top: 8px;
            display: inline-block;
        }

        #settingsPanel { border-color: #27ae60; }
        #settingsPanel .panel-header h2 { color: #2ecc71; }
        
        .settings-category { margin-bottom: 12px; }
        
        .settings-category-title {
            color: #8e2de2;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(142, 45, 226, 0.3);
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .setting-label { color: #ccc; font-size: 11px; }
        
        .toggle-switch {
            width: 40px;
            height: 20px;
            background: #444;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
            flex-shrink: 0;
        }
        
        .toggle-switch.on { background: #2ecc71; }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px; height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px; left: 2px;
            transition: left 0.3s;
        }
        
        .toggle-switch.on::after { left: 22px; }
        
        .slider-container { display: flex; align-items: center; gap: 6px; }
        
        .slider {
            width: 70px;
            height: 5px;
            -webkit-appearance: none;
            background: #444;
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px; height: 12px;
            background: #2ecc71;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value { color: #2ecc71; font-size: 10px; min-width: 25px; }
        
        #mobileControls {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #joystickZone {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 130px;
            height: 130px;
            pointer-events: none;
            z-index: 60;
        }
        
        #joystickBase {
            width: 110px;
            height: 110px;
            background: rgba(255, 255, 255, 0.12);
            border: 3px solid rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #joystickKnob {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.25));
            border-radius: 50%;
            position: absolute;
            will-change: transform;
        }
        
        .mobile-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
        }
        
        #attackBtn {
            bottom: 70px;
            right: 20px;
            width: 65px;
            height: 65px;
            font-size: 26px;
            background: rgba(255, 50, 50, 0.15);
            border-color: rgba(255, 100, 100, 0.3);
        }
        
        #jumpBtn {
            bottom: 155px;
            right: 20px;
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(150, 220, 255, 0.3);
        }
        
        #dashBtn {
            bottom: 70px;
            right: 105px;
            background: rgba(50, 150, 255, 0.15);
            border-color: rgba(100, 180, 255, 0.3);
        }
        
        .damage-number {
            position: fixed;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 150;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-35px) scale(0.5); }
        }
        
        .coin-pickup {
            position: fixed;
            color: gold;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            animation: coinFloat 1s forwards;
            z-index: 150;
        }
        
        @keyframes coinFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        #gameOver {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #gameOver h1 { font-size: 38px; color: #ff4444; margin-bottom: 12px; }
        #gameOver p { color: #fff; font-size: 14px; margin: 4px 0; }
        
        .mobile-mode #hud { bottom: 150px; left: 8px; }
        .mobile-mode .bar-container { width: 140px; height: 16px; }
        .mobile-mode #hotbar { bottom: 75px; transform: translateX(-50%) scale(0.8); }
    </style>
</head>
<body>
    <div id="menu">
        <h1>SHATTERREALMS</h1>
        <h2>Realism Edition</h2>
        <div id="deviceSelect">
            <p style="color: #aaa; margin-bottom: 15px;">Select your device:</p>
            <button class="menu-btn" onclick="selectDevice('computer')">üñ•Ô∏è Computer</button>
            <button class="menu-btn" onclick="selectDevice('mobile')">üì± Mobile</button>
        </div>
        <div id="startSection" style="display: none;">
            <button class="menu-btn" onclick="startGame()">‚öîÔ∏è Play</button>
            <button class="menu-btn shop-btn" onclick="openShop()">üõí Shop</button>
            <button class="menu-btn settings-btn" onclick="openSettings()">‚öôÔ∏è Settings</button>
            <button class="menu-btn quit-btn" onclick="quitGame()">üö™ Quit</button>
            <div id="menuCoins" style="color: gold; margin-top: 12px; font-size: 16px;">üí∞ 0</div>
        </div>
    </div>
    
    <div id="shopPanel" class="panel">
        <div class="panel-header">
            <h2>üõí SHOP</h2>
            <button class="close-btn" onclick="closeShop()">‚úï</button>
        </div>
        <div class="panel-content" id="shopItems"></div>
        <div class="coin-shop-section">
            <div class="coin-shop-title">üíé BUY COINS üíé</div>
            <div class="coin-packs">
                <div class="coin-pack" onclick="buyCoins('pack_500')">
                    <div class="coin-pack-amount">üí∞ 500</div>
                    <div class="coin-pack-price">$0.99</div>
                </div>
                <div class="coin-pack" onclick="buyCoins('pack_1200')">
                    <div class="coin-pack-amount">üí∞ 1,200</div>
                    <div class="coin-pack-bonus">+200 bonus!</div>
                    <div class="coin-pack-price">$1.99</div>
                </div>
                <div class="coin-pack popular" onclick="buyCoins('pack_3500')">
                    <div class="coin-pack-amount">üí∞ 3,500</div>
                    <div class="coin-pack-bonus">+700 bonus!</div>
                    <div class="coin-pack-price">$4.99</div>
                </div>
                <div class="coin-pack" onclick="buyCoins('pack_10000')">
                    <div class="coin-pack-amount">üí∞ 10,000</div>
                    <div class="coin-pack-bonus">+2,500 bonus!</div>
                    <div class="coin-pack-price">$9.99</div>
                </div>
            </div>
        </div>
    </div>

    <div id="settingsPanel" class="panel">
        <div class="panel-header">
            <h2>‚öôÔ∏è SETTINGS</h2>
            <button class="close-btn" onclick="closeSettings()">‚úï</button>
        </div>
        <div class="panel-content" id="settingsContent"></div>
    </div>
    
    <div id="mobileControls">
        <div id="joystickZone">
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <button id="attackBtn" class="mobile-btn">‚öîÔ∏è</button>
        <button id="jumpBtn" class="mobile-btn">‚¨ÜÔ∏è</button>
        <button id="dashBtn" class="mobile-btn">üí®</button>
    </div>
    
    <div id="hud" style="display: none;">
        <div id="healthBar" class="bar-container">
            <span class="bar-icon">‚ù§Ô∏è</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
        <div id="energyBar" class="bar-container">
            <span class="bar-icon">‚ö°</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
        <div id="abilityIndicators" style="display:flex; gap:8px; margin-top:5px;">
            <div id="dashIndicator" class="ability-icon" title="Dash [Q]">üí®</div>
            <div id="slideIndicator" class="ability-icon" title="Slide [C]">üèÉ</div>
            <div id="jumpIndicator" class="ability-icon" title="Jump [Space]">‚¨ÜÔ∏è</div>
            <div id="wallRunIndicator" class="ability-icon" title="Wall Run">üß±</div>
        </div>
    </div>

    <div id="coinsDisplay" style="display: none;">üí∞ 0</div>
    
    <div id="statsPanel" style="display: none;">
        <div><span class="stat-label">WAVE</span><br><span class="stat-value" id="waveNum">1</span></div>
        <div style="margin-top:5px;"><span class="stat-label">SCORE</span><br><span class="stat-value" id="score">0</span></div>
    </div>
    
    <div id="minimap" style="display: none;"><canvas id="minimapCanvas"></canvas></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="hotbar" style="display: none;"></div>
    <div id="waveAnnounce"></div>
    <div id="clickToPlay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 10px; font-size: 18px; z-index: 200; pointer-events: none;">Click to enable mouse controls</div>
    
    <div id="bossHealth">
        <div id="bossName">BOSS</div>
        <div id="bossBarContainer"><div id="bossFill"></div></div>
    </div>

    <!-- Chat System -->
    <div id="chatContainer">
        <div id="chatMessages"></div>
        <div id="chatInputArea">
            <input type="text" id="chatInput" placeholder="Press T to chat..." maxlength="200" />
            <button id="chatSend">Send</button>
        </div>
    </div>

    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Wave: <span id="finalWave">1</span></p>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Coins: <span id="finalCoins">0</span></p>
        <button class="menu-btn" onclick="restartGame()">‚öîÔ∏è Retry</button>
        <button class="menu-btn" onclick="backToMenu()">üè† Menu</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer, player;
        let gameRunning = false;
        let enemies = [];
        let projectiles = [];
        let coins = [];
        let colliders = [];
        let buildings = [];
        let boss = null;
        let deviceMode = 'computer';
        let playerState = null;
        let swordMesh = null;
        let swordSwinging = false;
        let swordSwingTime = 0;

        // Particle system
        let particles = [];

        // ============================================
        // PROCEDURAL GENERATION SYSTEM
        // ============================================
        const generatedChunks = new Set();
        const CHUNK_SIZE = 50;
        const lakes = [];

        function getChunkKey(x, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            return `${cx},${cz}`;
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 12.9898 + seed * 78.233) * 43758.5453;
            return x - Math.floor(x);
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (generatedChunks.has(key)) return;
            generatedChunks.add(key);

            const baseX = chunkX * CHUNK_SIZE;
            const baseZ = chunkZ * CHUNK_SIZE;
            const seed = chunkX * 10000 + chunkZ;

            // Don't generate in spawn area
            if (Math.abs(baseX) < 40 && Math.abs(baseZ) < 40) return;

            // Generate 1-3 houses per chunk
            const numHouses = Math.floor(seededRandom(seed) * 3) + 1;
            for (let i = 0; i < numHouses; i++) {
                const hx = baseX + seededRandom(seed + i * 100) * CHUNK_SIZE;
                const hz = baseZ + seededRandom(seed + i * 100 + 1) * CHUNK_SIZE;

                // Check if in lake
                let inLake = false;
                for (const lake of lakes) {
                    const dist = Math.sqrt((hx - lake.x) ** 2 + (hz - lake.z) ** 2);
                    if (dist < lake.radius + 5) { inLake = true; break; }
                }
                if (inLake) continue;

                generateHouse(hx, hz, seed + i);
            }

            // 30% chance for a lake in this chunk
            if (seededRandom(seed + 999) < 0.3) {
                const lx = baseX + CHUNK_SIZE / 2 + (seededRandom(seed + 500) - 0.5) * 30;
                const lz = baseZ + CHUNK_SIZE / 2 + (seededRandom(seed + 501) - 0.5) * 30;
                generateLake(lx, lz, seed);
            }
        }

        function generateHouse(x, z, seed) {
            const terrainY = getTerrainHeight(x, z);
            const houseGroup = new THREE.Group();

            // House dimensions based on seed
            const width = 4 + seededRandom(seed + 10) * 3;
            const depth = 4 + seededRandom(seed + 11) * 3;
            const height = 3 + seededRandom(seed + 12) * 2;

            // Wall colors
            const wallColors = [0xD2B48C, 0xF5DEB3, 0xCD853F, 0xDEB887, 0xE8E8E8];
            const roofColors = [0x8B4513, 0x654321, 0x8B0000, 0x2F4F4F, 0x696969];
            const wallColor = wallColors[Math.floor(seededRandom(seed + 20) * wallColors.length)];
            const roofColor = roofColors[Math.floor(seededRandom(seed + 21) * roofColors.length)];

            // Walls
            const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.85 });
            const wallThickness = 0.2;

            // Four walls
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(width, height, wallThickness), wallMat);
            frontWall.position.set(0, height / 2, depth / 2);
            frontWall.castShadow = true;
            houseGroup.add(frontWall);

            const backWall = new THREE.Mesh(new THREE.BoxGeometry(width, height, wallThickness), wallMat);
            backWall.position.set(0, height / 2, -depth / 2);
            backWall.castShadow = true;
            houseGroup.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, height, depth), wallMat);
            leftWall.position.set(-width / 2, height / 2, 0);
            leftWall.castShadow = true;
            houseGroup.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, height, depth), wallMat);
            rightWall.position.set(width / 2, height / 2, 0);
            rightWall.castShadow = true;
            houseGroup.add(rightWall);

            // Roof
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.7 });
            const roofGeo = new THREE.ConeGeometry(Math.max(width, depth) * 0.8, 2, 4);
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = height + 1;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);

            // Door
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const door = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.1), doorMat);
            door.position.set(0, 0.9, depth / 2 + 0.1);
            houseGroup.add(door);

            houseGroup.position.set(x, terrainY, z);
            houseGroup.rotation.y = seededRandom(seed + 30) * Math.PI * 2;
            scene.add(houseGroup);

            // Add collider
            colliders.push({
                position: { x, z },
                type: 'box',
                width: width + 1,
                depth: depth + 1
            });
        }

        function generateLake(x, z, seed) {
            const radius = 8 + seededRandom(seed + 200) * 12;
            const terrainY = getTerrainHeight(x, z);

            // Water surface
            const waterGeo = new THREE.CircleGeometry(radius, 32);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.3
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.set(x, terrainY - 0.3, z);
            water.receiveShadow = true;
            scene.add(water);

            // Lake shore (darker ring)
            const shoreGeo = new THREE.RingGeometry(radius, radius + 2, 32);
            const shoreMat = new THREE.MeshStandardMaterial({
                color: 0x5a4a3a,
                roughness: 0.9
            });
            const shore = new THREE.Mesh(shoreGeo, shoreMat);
            shore.rotation.x = -Math.PI / 2;
            shore.position.set(x, terrainY + 0.02, z);
            scene.add(shore);

            // Store lake for collision
            lakes.push({ x, z, radius, waterY: terrainY - 0.3 });

            // Add some rocks around
            for (let i = 0; i < 6; i++) {
                const angle = seededRandom(seed + 300 + i) * Math.PI * 2;
                const dist = radius + 1 + seededRandom(seed + 310 + i) * 3;
                const rx = x + Math.cos(angle) * dist;
                const rz = z + Math.sin(angle) * dist;
                const rockSize = 0.3 + seededRandom(seed + 320 + i) * 0.5;

                const rockGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(rx, getTerrainHeight(rx, rz) + rockSize * 0.5, rz);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        function updateProceduralGeneration() {
            if (!playerState) return;

            const px = playerState.position.x;
            const pz = playerState.position.z;

            // Generate chunks in a 3x3 area around player
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const chunkX = Math.floor(px / CHUNK_SIZE) + dx;
                    const chunkZ = Math.floor(pz / CHUNK_SIZE) + dz;
                    generateChunk(chunkX, chunkZ);
                }
            }
        }

        // ============================================
        // CHAT SYSTEM WITH MODERATION
        // ============================================
        let chatOpen = false;
        let chatMessages = [];
        const playerName = 'Player' + Math.floor(Math.random() * 9999);

        // Bad words filter (basic client-side)
        const badWords = ['fuck', 'shit', 'ass', 'bitch', 'damn', 'crap', 'dick', 'cock', 'pussy', 'bastard', 'slut', 'whore', 'fag', 'nigger', 'retard', 'kill yourself', 'kys'];

        function containsBadWords(text) {
            const lower = text.toLowerCase();
            for (const word of badWords) {
                if (lower.includes(word)) return true;
            }
            return false;
        }

        function blurText(text) {
            return text.replace(/./g, '*');
        }

        function toggleChat() {
            chatOpen = !chatOpen;
            const container = document.getElementById('chatContainer');
            const input = document.getElementById('chatInput');

            if (chatOpen) {
                container.style.display = 'block';
                input.focus();
                // Unlock pointer for typing
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            } else {
                container.style.display = 'none';
                // Re-lock pointer for game
                if (gameRunning) {
                    renderer.domElement.requestPointerLock();
                }
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            if (!text) return;

            input.value = '';

            // Check for bad words locally first
            let isFiltered = containsBadWords(text);
            let displayText = text;
            let messageClass = 'player';

            if (isFiltered) {
                displayText = blurText(text);
                messageClass = 'filtered';
            } else {
                // Send to server for Claude moderation
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: text, player: playerName })
                    });
                    const data = await response.json();

                    if (data.filtered) {
                        displayText = data.filteredText || blurText(text);
                        messageClass = 'filtered';
                        isFiltered = true;
                    }
                } catch (e) {
                    console.log('Chat moderation unavailable, using local filter');
                }
            }

            addChatMessage(playerName, displayText, messageClass, isFiltered);
        }

        function addChatMessage(name, text, type = 'player', isFiltered = false) {
            const messagesDiv = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            msg.className = `chat-message ${type}`;

            if (isFiltered) {
                msg.innerHTML = `<span class="name">${name}:</span> <span class="filtered-text" title="Message filtered">${text}</span>`;
            } else {
                msg.innerHTML = `<span class="name">${name}:</span> <span class="text">${text}</span>`;
            }

            messagesDiv.appendChild(msg);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Keep only last 50 messages
            while (messagesDiv.children.length > 50) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }

            chatMessages.push({ name, text, type, time: Date.now() });
        }

        function addSystemMessage(text) {
            addChatMessage('System', text, 'system');
        }

        function initChat() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSend');

            input.addEventListener('keydown', (e) => {
                e.stopPropagation(); // Prevent game controls

                if (e.key === 'Enter') {
                    sendChatMessage();
                } else if (e.key === 'Escape') {
                    toggleChat();
                }
            });

            sendBtn.addEventListener('click', sendChatMessage);

            // T key to open chat
            document.addEventListener('keydown', (e) => {
                if (e.code === 'KeyT' && !chatOpen && gameRunning) {
                    e.preventDefault();
                    toggleChat();
                }
            });

            addSystemMessage('Welcome to ShatterRealms! Press T to chat.');
        }

        // ============================================
        // SOUND SYSTEM - Web Audio API
        // ============================================
        let audioCtx = null;
        let soundEnabled = true;
        let masterVolume = 0.5;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Create oscillator-based sound effect
        function playTone(frequency, duration, type = 'sine', volume = 0.3, attack = 0.01, decay = 0.1) {
            if (!soundEnabled || !audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(volume * masterVolume, audioCtx.currentTime + attack);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        // Create noise-based sound (for impacts, whooshes)
        function playNoise(duration, volume = 0.2, filterFreq = 1000) {
            if (!soundEnabled || !audioCtx) return;
            try {
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(volume * masterVolume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            } catch(e) {}
        }

        // Sound Effects Library
        const SFX = {
            swordSwing: () => {
                playNoise(0.15, 0.25, 2000);
                playTone(200, 0.1, 'sawtooth', 0.1);
            },
            swordHit: () => {
                playNoise(0.1, 0.4, 3000);
                playTone(150, 0.15, 'square', 0.2);
                playTone(100, 0.1, 'sine', 0.15);
            },
            enemyHit: () => {
                playTone(300, 0.1, 'square', 0.2);
                playNoise(0.08, 0.2, 2500);
            },
            enemyDeath: () => {
                playTone(200, 0.3, 'sawtooth', 0.25);
                playTone(100, 0.4, 'sine', 0.2);
                playNoise(0.2, 0.3, 1500);
            },
            playerHit: () => {
                playTone(150, 0.2, 'square', 0.3);
                playTone(80, 0.25, 'sine', 0.25);
            },
            playerDeath: () => {
                playTone(200, 0.5, 'sawtooth', 0.3);
                playTone(100, 0.6, 'sine', 0.25);
                playTone(50, 0.8, 'sine', 0.2);
            },
            fireball: () => {
                playNoise(0.3, 0.2, 800);
                playTone(400, 0.2, 'sine', 0.15);
                playTone(200, 0.3, 'triangle', 0.1);
            },
            explosion: () => {
                playNoise(0.4, 0.5, 500);
                playTone(80, 0.3, 'sine', 0.3);
                playTone(40, 0.4, 'sine', 0.2);
            },
            coinPickup: () => {
                playTone(800, 0.1, 'sine', 0.2);
                setTimeout(() => playTone(1000, 0.1, 'sine', 0.2), 50);
                setTimeout(() => playTone(1200, 0.15, 'sine', 0.15), 100);
            },
            jump: () => {
                playTone(200, 0.15, 'sine', 0.15);
                playTone(400, 0.1, 'sine', 0.1);
            },
            dash: () => {
                playNoise(0.15, 0.2, 1500);
                playTone(300, 0.1, 'sawtooth', 0.1);
            },
            footstep: () => {
                playNoise(0.05, 0.08, 400);
            },
            bossRoar: () => {
                playTone(80, 0.6, 'sawtooth', 0.4);
                playTone(60, 0.8, 'sine', 0.3);
                playNoise(0.5, 0.3, 300);
            },
            dragonRoar: () => {
                playTone(100, 0.8, 'sawtooth', 0.35);
                playTone(150, 0.6, 'square', 0.2);
                playNoise(0.6, 0.35, 400);
                setTimeout(() => playTone(80, 0.5, 'sine', 0.3), 200);
            },
            magic: () => {
                playTone(600, 0.2, 'sine', 0.2);
                playTone(800, 0.15, 'triangle', 0.15);
                playTone(1000, 0.1, 'sine', 0.1);
            },
            heal: () => {
                playTone(400, 0.15, 'sine', 0.2);
                playTone(600, 0.15, 'sine', 0.2);
                playTone(800, 0.2, 'sine', 0.15);
            },
            waveStart: () => {
                playTone(300, 0.3, 'square', 0.2);
                setTimeout(() => playTone(400, 0.3, 'square', 0.2), 150);
                setTimeout(() => playTone(500, 0.4, 'square', 0.25), 300);
            },
            menuClick: () => {
                playTone(600, 0.08, 'sine', 0.15);
            },
            bowShoot: () => {
                playNoise(0.1, 0.15, 2500);
                playTone(250, 0.08, 'triangle', 0.1);
            },
            shieldBlock: () => {
                playTone(200, 0.15, 'square', 0.25);
                playNoise(0.1, 0.2, 1000);
            }
        };

        // Footstep timer
        let footstepTimer = 0;

        // ============================================
        // BACKGROUND MUSIC SYSTEM
        // ============================================
        let musicPlaying = false;
        let musicOscillators = [];
        let musicGain = null;
        let musicVolume = 0.15;
        let musicEnabled = true;

        function startBackgroundMusic() {
            if (!audioCtx || musicPlaying || !musicEnabled) return;
            musicPlaying = true;

            // Create master gain for music
            musicGain = audioCtx.createGain();
            musicGain.gain.setValueAtTime(musicVolume, audioCtx.currentTime);
            musicGain.connect(audioCtx.destination);

            // Epic fantasy music using layered oscillators
            const bpm = 80;
            const beatDuration = 60 / bpm;

            // Bass line - deep atmospheric drone
            function playBassLoop() {
                if (!musicPlaying) return;
                const bassNotes = [55, 55, 73.4, 65.4, 55, 82.4, 73.4, 55]; // A1, A1, D2, C2, etc
                let time = audioCtx.currentTime;

                bassNotes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, time + i * beatDuration);
                    gain.gain.setValueAtTime(0, time + i * beatDuration);
                    gain.gain.linearRampToValueAtTime(0.3, time + i * beatDuration + 0.1);
                    gain.gain.setValueAtTime(0.3, time + i * beatDuration + beatDuration * 0.8);
                    gain.gain.linearRampToValueAtTime(0, time + i * beatDuration + beatDuration);
                    osc.connect(gain);
                    gain.connect(musicGain);
                    osc.start(time + i * beatDuration);
                    osc.stop(time + i * beatDuration + beatDuration);
                });

                setTimeout(playBassLoop, bassNotes.length * beatDuration * 1000);
            }

            // Pad/atmosphere - sustained chords
            function playPadLoop() {
                if (!musicPlaying) return;
                const chords = [
                    [220, 277.2, 329.6], // Am
                    [220, 277.2, 329.6],
                    [293.7, 349.2, 440], // Dm
                    [261.6, 329.6, 392], // C
                    [220, 277.2, 329.6], // Am
                    [246.9, 311.1, 370], // Bm
                    [293.7, 349.2, 440], // Dm
                    [329.6, 415.3, 493.9] // Em
                ];

                let time = audioCtx.currentTime;
                const chordDuration = beatDuration * 2;

                chords.forEach((chord, i) => {
                    chord.forEach(freq => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, time + i * chordDuration);
                        gain.gain.setValueAtTime(0, time + i * chordDuration);
                        gain.gain.linearRampToValueAtTime(0.08, time + i * chordDuration + 0.3);
                        gain.gain.setValueAtTime(0.08, time + i * chordDuration + chordDuration * 0.7);
                        gain.gain.linearRampToValueAtTime(0, time + i * chordDuration + chordDuration);
                        osc.connect(gain);
                        gain.connect(musicGain);
                        osc.start(time + i * chordDuration);
                        osc.stop(time + i * chordDuration + chordDuration);
                    });
                });

                setTimeout(playPadLoop, chords.length * chordDuration * 1000);
            }

            // Melody - heroic theme
            function playMelodyLoop() {
                if (!musicPlaying) return;
                const melody = [
                    { note: 440, dur: 0.5 },    // A4
                    { note: 523.3, dur: 0.5 },  // C5
                    { note: 587.3, dur: 1 },    // D5
                    { note: 523.3, dur: 0.5 },  // C5
                    { note: 440, dur: 0.5 },    // A4
                    { note: 392, dur: 1 },      // G4
                    { note: 440, dur: 0.5 },    // A4
                    { note: 493.9, dur: 0.5 },  // B4
                    { note: 523.3, dur: 1 },    // C5
                    { note: 493.9, dur: 0.5 },  // B4
                    { note: 440, dur: 0.5 },    // A4
                    { note: 392, dur: 1 },      // G4
                    { note: 349.2, dur: 0.5 },  // F4
                    { note: 392, dur: 0.5 },    // G4
                    { note: 440, dur: 2 },      // A4
                ];

                let time = audioCtx.currentTime;
                let offset = 0;

                melody.forEach((note) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(note.note, time + offset * beatDuration);

                    const noteDur = note.dur * beatDuration;
                    gain.gain.setValueAtTime(0, time + offset * beatDuration);
                    gain.gain.linearRampToValueAtTime(0.12, time + offset * beatDuration + 0.05);
                    gain.gain.setValueAtTime(0.1, time + offset * beatDuration + noteDur * 0.6);
                    gain.gain.linearRampToValueAtTime(0, time + offset * beatDuration + noteDur);

                    osc.connect(gain);
                    gain.connect(musicGain);
                    osc.start(time + offset * beatDuration);
                    osc.stop(time + offset * beatDuration + noteDur);

                    offset += note.dur;
                });

                setTimeout(playMelodyLoop, offset * beatDuration * 1000);
            }

            // Percussion - subtle drums
            function playPercLoop() {
                if (!musicPlaying) return;
                const pattern = [1, 0, 0.5, 0, 1, 0, 0.5, 0.3, 1, 0, 0.5, 0, 1, 0.3, 0.5, 0];
                let time = audioCtx.currentTime;
                const hitDur = beatDuration * 0.5;

                pattern.forEach((vol, i) => {
                    if (vol > 0) {
                        // Kick-like sound
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(80, time + i * hitDur);
                        osc.frequency.exponentialRampToValueAtTime(40, time + i * hitDur + 0.1);
                        gain.gain.setValueAtTime(vol * 0.2, time + i * hitDur);
                        gain.gain.exponentialRampToValueAtTime(0.001, time + i * hitDur + 0.15);
                        osc.connect(gain);
                        gain.connect(musicGain);
                        osc.start(time + i * hitDur);
                        osc.stop(time + i * hitDur + 0.2);
                    }
                });

                setTimeout(playPercLoop, pattern.length * hitDur * 1000);
            }

            // Start all music layers
            playBassLoop();
            setTimeout(playPadLoop, 500);
            setTimeout(playMelodyLoop, 2000);
            setTimeout(playPercLoop, 1000);
        }

        function stopBackgroundMusic() {
            musicPlaying = false;
            if (musicGain) {
                musicGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            }
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopBackgroundMusic();
            } else {
                startBackgroundMusic();
            }
        }

        // ============================================
        // HITBOX VISUALIZATION SYSTEM
        // ============================================
        let showHitboxes = false;
        let hitboxMeshes = [];

        function toggleHitboxes() {
            showHitboxes = !showHitboxes;
            if (!showHitboxes) {
                // Remove all hitbox visualizations
                hitboxMeshes.forEach(m => scene.remove(m));
                hitboxMeshes = [];
            }
            console.log('Hitboxes:', showHitboxes ? 'ON' : 'OFF');
        }

        function updateHitboxVisualization() {
            if (!showHitboxes) return;

            // Clear old hitbox meshes
            hitboxMeshes.forEach(m => scene.remove(m));
            hitboxMeshes = [];

            const hitboxMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });

            const bossHitboxMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });

            const playerHitboxMat = new THREE.MeshBasicMaterial({
                color: 0x0088ff,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });

            const attackRangeMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });

            // Enemy hitboxes
            enemies.forEach(e => {
                if (!e.mesh || e.dying) return;
                const hitbox = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 1.6, 12),
                    hitboxMat
                );
                hitbox.position.copy(e.mesh.position);
                hitbox.position.y += 0.8;
                scene.add(hitbox);
                hitboxMeshes.push(hitbox);

                // Enemy attack range
                const attackRange = new THREE.Mesh(
                    new THREE.RingGeometry(1.4, 1.5, 24),
                    attackRangeMat
                );
                attackRange.position.copy(e.mesh.position);
                attackRange.position.y += 0.1;
                attackRange.rotation.x = -Math.PI / 2;
                scene.add(attackRange);
                hitboxMeshes.push(attackRange);
            });

            // Boss hitbox
            if (boss && boss.mesh) {
                const bossSize = boss.type === 'dragon' ? { r: 1.5, h: 3 } : { r: 1, h: 2.5 };
                const bossHitbox = new THREE.Mesh(
                    new THREE.CylinderGeometry(bossSize.r, bossSize.r, bossSize.h, 16),
                    bossHitboxMat
                );
                bossHitbox.position.copy(boss.mesh.position);
                bossHitbox.position.y += bossSize.h / 2;
                scene.add(bossHitbox);
                hitboxMeshes.push(bossHitbox);

                // Boss attack range
                const bossAttackRange = boss.type === 'dragon' ? 4 : 3;
                const bossRange = new THREE.Mesh(
                    new THREE.RingGeometry(bossAttackRange - 0.1, bossAttackRange, 32),
                    bossHitboxMat
                );
                bossRange.position.copy(boss.mesh.position);
                bossRange.position.y += 0.1;
                bossRange.rotation.x = -Math.PI / 2;
                scene.add(bossRange);
                hitboxMeshes.push(bossRange);
            }

            // Player hitbox
            const playerHitbox = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 1.7, 12),
                playerHitboxMat
            );
            playerHitbox.position.copy(playerState.position);
            scene.add(playerHitbox);
            hitboxMeshes.push(playerHitbox);

            // Player attack range (cone visualization)
            const attackRange = 2.5;
            const attackCone = new THREE.Mesh(
                new THREE.ConeGeometry(attackRange * 0.7, attackRange, 16, 1, true),
                attackRangeMat
            );
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            attackCone.position.copy(playerState.position);
            attackCone.position.add(dir.clone().multiplyScalar(attackRange / 2));
            attackCone.lookAt(playerState.position);
            attackCone.rotateX(Math.PI / 2);
            scene.add(attackCone);
            hitboxMeshes.push(attackCone);
        }

        // Create text sprite for labels (BOSS text above boss head)
        function createTextSprite(text, fontSize, color, bgColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;

            // Background
            if (bgColor) {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Text with outline
            ctx.font = `bold ${fontSize}px Arial Black, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Black outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 8;
            ctx.strokeText(text, canvas.width / 2, canvas.height / 2);

            // Fill
            ctx.fillStyle = color;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(4, 1, 1);
            return sprite;
        }

        // Particle creation functions
        function createParticles(position, color, count, speed, size, lifetime, spread = 1) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(size * (0.5 + Math.random() * 0.5), 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.3) * spread,
                    (Math.random() - 0.5) * spread
                ).normalize().multiplyScalar(speed * (0.5 + Math.random() * 0.5));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: lifetime,
                    maxLife: lifetime,
                    gravity: 0.0003,
                    shrink: true
                });
            }
        }

        function createSparkParticles(position, color, count) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.BoxGeometry(0.03, 0.18, 0.03);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const upAngle = Math.random() * Math.PI * 0.5;
                const speed = 0.05 + Math.random() * 0.1;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * Math.sin(upAngle) * speed,
                    Math.cos(upAngle) * speed,
                    Math.sin(angle) * Math.sin(upAngle) * speed
                );

                particle.lookAt(particle.position.clone().add(velocity));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 400 + Math.random() * 300,
                    maxLife: 700,
                    gravity: 0.0008,
                    shrink: false,
                    trail: true
                });
            }
        }

        function createMagicParticles(position, color, count, size = 0.08) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.OctahedronGeometry(size * (0.6 + Math.random() * 0.4), 0);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9555
                });
                const particle = new THREE.Mesh(geo, mat);

                // Spiral outward pattern
                const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                const radius = 0.2 + Math.random() * 0.3;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * radius;
                particle.position.z += Math.sin(angle) * radius;
                particle.position.y += (Math.random() - 0.5) * 0.5;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * 0.02,
                    0.02 + Math.random() * 0.03,
                    Math.sin(angle) * 0.02
                );

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 600 + Math.random() * 400,
                    maxLife: 1000,
                    gravity: -0.0001, // Float upward
                    shrink: true,
                    spin: true,
                    spinSpeed: 0.05 + Math.random() * 0.05
                });
            }
        }

        function createExplosionParticles(position, color, secondaryColor) {
            // Core explosion particles
            createParticles(position, color, 45, 0.15, 0.12, 500, 2);
            // Secondary colored particles
            createParticles(position, secondaryColor, 15, 0.12, 0.08, 400, 1.5);
            // Spark trails
            createSparkParticles(position, 0xffff00, 12);
            // Smoke
            createParticles(position, 0x444444, 10, 0.03, 0.2, 800, 0.8);
        }

        function createHitParticles(position, color) {
            createParticles(position, color, 8, 0.06, 0.05, 300, 0.8);
            createSparkParticles(position, 0xffffff, 5);
        }

        function createDeathParticles(position, color) {
            createParticles(position, color, 50, 0.08, 0.1, 600, 1.5);
            createMagicParticles(position, 0xff0000, 15, 0.06);
            createParticles(position, 0x220000, 20, 0.04, 0.15, 800, 1);
        }

        function createSlashParticles(position, direction, color) {
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.PlaneGeometry(0.04, 0.25);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Arc pattern
                const arcAngle = (i / 12) * Math.PI - Math.PI / 2;
                const offset = new THREE.Vector3(
                    Math.cos(arcAngle) * 0.3,
                    Math.sin(arcAngle) * 0.3,
                    0
                );

                // Rotate offset to match direction
                const rotation = Math.atan2(direction.x, direction.z);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                particle.position.add(offset);

                particle.rotation.y = rotation;
                particle.rotation.x = arcAngle;

                const velocity = offset.clone().normalize().multiplyScalar(0.03);

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 200 + Math.random() * 100,
                    maxLife: 300,
                    gravity: 0,
                    shrink: true
                });
            }
        }

        function createProjectileTrail(position, color) {
            const geo = new THREE.SphereGeometry(0.06, 4, 4);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.copy(position);

            scene.add(particle);
            particles.push({
                mesh: particle,
                velocity: new THREE.Vector3(0, 0.005, 0),
                life: 150,
                maxLife: 150,
                gravity: 0,
                shrink: true
            });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Update position
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt / 16));

                // Apply gravity
                p.velocity.y -= p.gravity * dt;

                // Update life
                p.life -= dt;
                const lifeRatio = p.life / p.maxLife;

                // Fade out
                p.mesh.material.opacity = lifeRatio;

                // Shrink
                if (p.shrink) {
                    const scale = 0.3 + lifeRatio * 0.7;
                    p.mesh.scale.setScalar(scale);
                }

                // Spin
                if (p.spin) {
                    p.mesh.rotation.x += p.spinSpeed;
                    p.mesh.rotation.y += p.spinSpeed * 0.7;
                }

                // Remove dead particles
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // Settings
        const settings = {
            autoJump: false,
            autoCollectCoins: true,
            walkSpeed: 30,
            sprintSpeed: 30,
            sensitivity: 50,
            invertY: false,
            showDamageNumbers: true,
            showMinimap: true
        };
        
        // Inventory
        const inventory = { coins: 100, ownedItems: ['sword', 'fireball'] };

        // Cloud save functions
        let cloudDataLoaded = false;

        async function loadFromCloud() {
            try {
                const response = await fetch('/api/save');
                const data = await response.json();
                inventory.coins = data.coins;
                if (data.ownedItems && data.ownedItems.length > 0) {
                    inventory.ownedItems = data.ownedItems;
                }
                // Update coin displays
                const menuCoins = document.getElementById('menuCoins');
                const coinsDisplay = document.getElementById('coinsDisplay');
                if (menuCoins) menuCoins.textContent = 'üí∞ ' + inventory.coins;
                if (coinsDisplay) coinsDisplay.textContent = 'üí∞ ' + inventory.coins;

                cloudDataLoaded = true;
                console.log('Loaded from cloud:', inventory);
            } catch (e) {
                console.log('Could not load from cloud, using defaults');
                cloudDataLoaded = true;
            }
        }

        function syncHotbarWithInventory() {
            // Ensure sword and fireball are always owned
            if (!inventory.ownedItems.includes('sword')) {
                inventory.ownedItems.unshift('sword');
            }
            if (!inventory.ownedItems.includes('fireball')) {
                if (inventory.ownedItems.length < 2) {
                    inventory.ownedItems.push('fireball');
                } else {
                    inventory.ownedItems.splice(1, 0, 'fireball');
                }
            }
            // Put all owned items in hotbar (up to 6)
            hotbar = [null, null, null, null, null, null];
            for (let i = 0; i < Math.min(inventory.ownedItems.length, 6); i++) {
                hotbar[i] = inventory.ownedItems[i];
            }
            console.log('Hotbar synced:', hotbar);
            console.log('Inventory:', inventory.ownedItems);
        }

        async function saveToCloud() {
            try {
                await fetch('/api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        coins: inventory.coins,
                        ownedItems: inventory.ownedItems
                    })
                });
                console.log('Saved to cloud:', inventory);
            } catch (e) {
                console.log('Could not save to cloud');
            }
        }

        // Alias for backward compatibility
        const saveCoinsToCloud = saveToCloud;

        // Load save when page loads
        loadFromCloud();

        // Items
        const itemDefs = {
            // === STARTER WEAPONS ===
            sword: { name: 'Sword', icon: '‚öîÔ∏è', type: 'weapon', damage: 25, cooldown: 500, desc: 'Basic melee attack' },
            fireball: { name: 'Fireball', icon: 'üî•', type: 'ability', damage: 40, cooldown: 2000, energy: 15, desc: 'Ranged fire attack' },

            // === MELEE WEAPONS ===
            axe: { name: 'Battle Axe', icon: 'ü™ì', type: 'weapon', damage: 45, cooldown: 800, desc: 'Heavy melee damage' },
            spear: { name: 'Spear', icon: 'üî±', type: 'weapon', damage: 35, cooldown: 600, desc: 'Long reach attack' },
            hammer: { name: 'War Hammer', icon: 'üî®', type: 'weapon', damage: 60, cooldown: 1200, desc: 'Massive damage, slow' },
            dagger: { name: 'Dagger', icon: 'üó°Ô∏è', type: 'weapon', damage: 18, cooldown: 250, desc: 'Fast attack speed' },
            katana: { name: 'Katana', icon: '‚öîÔ∏è', type: 'weapon', damage: 38, cooldown: 400, desc: 'Swift blade strikes' },
            scythe: { name: 'Scythe', icon: 'üåô', type: 'weapon', damage: 55, cooldown: 900, desc: 'Reaper\'s weapon' },
            mace: { name: 'Mace', icon: 'üèè', type: 'weapon', damage: 42, cooldown: 700, desc: 'Crushing blows' },
            flail: { name: 'Flail', icon: '‚õìÔ∏è', type: 'weapon', damage: 48, cooldown: 850, desc: 'Chain weapon' },
            halberd: { name: 'Halberd', icon: 'ü™ì', type: 'weapon', damage: 52, cooldown: 950, desc: 'Polearm attack' },
            claws: { name: 'Wolf Claws', icon: 'üê∫', type: 'weapon', damage: 22, cooldown: 200, desc: 'Rapid slashes' },
            gauntlet: { name: 'Power Gauntlet', icon: 'ü•ä', type: 'weapon', damage: 35, cooldown: 450, desc: 'Punch attack' },
            chainsaw: { name: 'Chainsaw', icon: 'ü™ö', type: 'weapon', damage: 65, cooldown: 300, desc: 'Brutal damage' },
            pickaxe: { name: 'Pickaxe', icon: '‚õèÔ∏è', type: 'weapon', damage: 40, cooldown: 650, desc: 'Mining tool turned weapon' },
            shovel: { name: 'Battle Shovel', icon: 'ü™†', type: 'weapon', damage: 28, cooldown: 500, desc: 'Blunt force' },
            sickle: { name: 'Sickle', icon: 'üåæ', type: 'weapon', damage: 32, cooldown: 350, desc: 'Curved blade' },
            nunchucks: { name: 'Nunchucks', icon: 'ü•¢', type: 'weapon', damage: 26, cooldown: 280, desc: 'Martial arts weapon' },
            bo_staff: { name: 'Bo Staff', icon: 'üéã', type: 'weapon', damage: 30, cooldown: 400, desc: 'Long range melee' },
            whip: { name: 'Whip', icon: '„Ä∞Ô∏è', type: 'weapon', damage: 24, cooldown: 350, desc: 'Long reach' },
            anchor: { name: 'Anchor', icon: '‚öì', type: 'weapon', damage: 75, cooldown: 1500, desc: 'Extremely heavy' },
            wrench: { name: 'Giant Wrench', icon: 'üîß', type: 'weapon', damage: 38, cooldown: 550, desc: 'Tool of destruction' },

            // === LEGENDARY MELEE ===
            excalibur: { name: 'Excalibur', icon: 'üó°Ô∏è', type: 'weapon', damage: 85, cooldown: 600, desc: 'Legendary blade' },
            mjolnir: { name: 'Mjolnir', icon: 'üî®', type: 'weapon', damage: 95, cooldown: 1000, desc: 'Thor\'s hammer' },
            gungnir: { name: 'Gungnir', icon: 'üî±', type: 'weapon', damage: 80, cooldown: 700, desc: 'Odin\'s spear' },
            kusanagi: { name: 'Kusanagi', icon: '‚öîÔ∏è', type: 'weapon', damage: 88, cooldown: 450, desc: 'Divine blade' },

            // === RANGED WEAPONS ===
            bow: { name: 'Bow', icon: 'üèπ', type: 'ranged', damage: 35, cooldown: 800, desc: 'Arrow shot' },
            crossbow: { name: 'Crossbow', icon: 'üéØ', type: 'ranged', damage: 50, cooldown: 1200, desc: 'Powerful bolt' },
            shuriken: { name: 'Shuriken', icon: '‚ú¥Ô∏è', type: 'ranged', damage: 20, cooldown: 300, desc: 'Throwing star' },
            javelin: { name: 'Javelin', icon: 'üéø', type: 'ranged', damage: 45, cooldown: 900, desc: 'Throwing spear' },
            boomerang: { name: 'Boomerang', icon: 'ü™É', type: 'ranged', damage: 28, cooldown: 600, desc: 'Returns to you' },
            kunai: { name: 'Kunai', icon: 'üìç', type: 'ranged', damage: 22, cooldown: 350, desc: 'Ninja knife' },
            chakram: { name: 'Chakram', icon: 'üíø', type: 'ranged', damage: 38, cooldown: 700, desc: 'Spinning disc' },
            blowdart: { name: 'Blowdart', icon: 'üé∫', type: 'ranged', damage: 15, cooldown: 400, desc: 'Poison dart' },

            // === MAGIC SPELLS ===
            iceball: { name: 'Ice Blast', icon: '‚ùÑÔ∏è', type: 'ability', damage: 35, cooldown: 1800, energy: 12, desc: 'Freezing projectile' },
            lightning: { name: 'Lightning', icon: '‚ö°', type: 'ability', damage: 55, cooldown: 2500, energy: 25, desc: 'Chain lightning' },
            poison: { name: 'Poison Cloud', icon: '‚ò†Ô∏è', type: 'ability', damage: 30, cooldown: 3000, energy: 20, desc: 'AOE poison damage' },
            laser: { name: 'Laser Beam', icon: 'üî¥', type: 'ability', damage: 70, cooldown: 3500, energy: 35, desc: 'Powerful beam attack' },
            meteor: { name: 'Meteor', icon: '‚òÑÔ∏è', type: 'ability', damage: 90, cooldown: 5000, energy: 50, desc: 'Massive impact' },
            tornado: { name: 'Tornado', icon: 'üå™Ô∏è', type: 'ability', damage: 45, cooldown: 3000, energy: 30, desc: 'Spinning winds' },
            earthquake: { name: 'Earthquake', icon: 'üåã', type: 'ability', damage: 60, cooldown: 4000, energy: 40, desc: 'Ground shaker' },
            tsunami: { name: 'Tsunami', icon: 'üåä', type: 'ability', damage: 55, cooldown: 3500, energy: 35, desc: 'Water wave' },
            vortex: { name: 'Void Vortex', icon: 'üï≥Ô∏è', type: 'ability', damage: 75, cooldown: 4500, energy: 45, desc: 'Black hole' },
            solar: { name: 'Solar Flare', icon: '‚òÄÔ∏è', type: 'ability', damage: 65, cooldown: 3000, energy: 32, desc: 'Blinding light' },
            lunar: { name: 'Lunar Strike', icon: 'üåô', type: 'ability', damage: 58, cooldown: 2800, energy: 28, desc: 'Moon power' },
            arcane: { name: 'Arcane Blast', icon: 'üîÆ', type: 'ability', damage: 50, cooldown: 2200, energy: 22, desc: 'Pure magic' },
            nature: { name: 'Nature\'s Wrath', icon: 'üåø', type: 'ability', damage: 42, cooldown: 2500, energy: 20, desc: 'Plant attack' },
            shadow: { name: 'Shadow Bolt', icon: 'üñ§', type: 'ability', damage: 48, cooldown: 1800, energy: 18, desc: 'Dark magic' },
            holy: { name: 'Holy Light', icon: '‚ú®', type: 'ability', damage: 52, cooldown: 2000, energy: 24, desc: 'Divine damage' },
            plasma: { name: 'Plasma Ball', icon: 'üü£', type: 'ability', damage: 62, cooldown: 2400, energy: 28, desc: 'Energy sphere' },
            gravity: { name: 'Gravity Well', icon: '‚¨õ', type: 'ability', damage: 55, cooldown: 3200, energy: 35, desc: 'Crushing force' },
            chain_lightning: { name: 'Chain Lightning', icon: '‚õàÔ∏è', type: 'ability', damage: 40, cooldown: 2000, energy: 22, desc: 'Bouncing shock' },
            frost_nova: { name: 'Frost Nova', icon: 'üí†', type: 'ability', damage: 35, cooldown: 2500, energy: 25, desc: 'AOE freeze' },
            fire_storm: { name: 'Fire Storm', icon: 'üî•', type: 'ability', damage: 70, cooldown: 4000, energy: 40, desc: 'Raining fire' },

            // === LEGENDARY MAGIC ===
            supernova: { name: 'Supernova', icon: 'üí•', type: 'ability', damage: 150, cooldown: 8000, energy: 80, desc: 'Ultimate explosion' },
            apocalypse: { name: 'Apocalypse', icon: 'üåë', type: 'ability', damage: 200, cooldown: 12000, energy: 100, desc: 'World ender' },
            genesis: { name: 'Genesis Beam', icon: 'üåü', type: 'ability', damage: 120, cooldown: 6000, energy: 60, desc: 'Creation energy' },
            oblivion: { name: 'Oblivion', icon: 'üíÄ', type: 'ability', damage: 180, cooldown: 10000, energy: 90, desc: 'Erase from existence' },

            // === UTILITY ITEMS ===
            shield: { name: 'Shield', icon: 'üõ°Ô∏è', type: 'ability', cooldown: 6000, energy: 20, desc: '+20 defense 4s' },
            medkit: { name: 'Medkit', icon: 'üíä', type: 'consumable', healing: 50, cooldown: 4000, desc: 'Heal 50 HP' },
            megaHeal: { name: 'Mega Heal', icon: 'üíâ', type: 'consumable', healing: 100, cooldown: 8000, desc: 'Full heal' },
            jumpPad: { name: 'Jump Pad', icon: 'ü¶ò', type: 'ability', cooldown: 3000, energy: 10, desc: 'Super jump' },
            speedBoost: { name: 'Speed Boost', icon: 'üí®', type: 'ability', cooldown: 5000, energy: 15, desc: '2x speed 3s' },
            rage: { name: 'Rage Mode', icon: 'üò°', type: 'ability', cooldown: 10000, energy: 40, desc: '2x damage 5s' },
            invisibility: { name: 'Invisibility', icon: 'üëª', type: 'ability', cooldown: 15000, energy: 50, desc: 'Vanish 5s' },
            teleport: { name: 'Teleport', icon: 'üåÄ', type: 'ability', cooldown: 8000, energy: 30, desc: 'Blink forward' },
            reflect: { name: 'Reflect Shield', icon: 'ü™û', type: 'ability', cooldown: 10000, energy: 35, desc: 'Reflect damage' },
            lifesteal: { name: 'Lifesteal', icon: 'üßõ', type: 'ability', cooldown: 12000, energy: 45, desc: 'Drain health' },
            timestop: { name: 'Time Stop', icon: '‚è∞', type: 'ability', cooldown: 20000, energy: 60, desc: 'Freeze time 3s' },
            clone: { name: 'Shadow Clone', icon: 'üë•', type: 'ability', cooldown: 15000, energy: 40, desc: 'Create decoy' },
            berserk: { name: 'Berserk', icon: 'üî¥', type: 'ability', cooldown: 18000, energy: 55, desc: '3x damage, take 2x' },
            fortify: { name: 'Fortify', icon: 'üè∞', type: 'ability', cooldown: 12000, energy: 35, desc: '+50 defense 6s' },
            regenerate: { name: 'Regeneration', icon: 'üíö', type: 'ability', cooldown: 20000, energy: 40, desc: 'Heal over time' },
            energize: { name: 'Energize', icon: 'üîã', type: 'ability', cooldown: 15000, energy: 0, desc: 'Restore 50 energy' },

            // === BOMBS & EXPLOSIVES ===
            grenade: { name: 'Grenade', icon: 'üí£', type: 'ability', damage: 80, cooldown: 4000, energy: 25, desc: 'Explosive' },
            dynamite: { name: 'Dynamite', icon: 'üß®', type: 'ability', damage: 100, cooldown: 5000, energy: 35, desc: 'Big explosion' },
            molotov: { name: 'Molotov', icon: 'üçæ', type: 'ability', damage: 60, cooldown: 3500, energy: 20, desc: 'Fire bomb' },
            flashbang: { name: 'Flashbang', icon: 'üí°', type: 'ability', damage: 10, cooldown: 6000, energy: 15, desc: 'Stun enemies' },
            smoke_bomb: { name: 'Smoke Bomb', icon: 'üí≠', type: 'ability', damage: 0, cooldown: 5000, energy: 10, desc: 'Cover escape' },
            cluster_bomb: { name: 'Cluster Bomb', icon: 'üéÜ', type: 'ability', damage: 120, cooldown: 7000, energy: 50, desc: 'Multiple explosions' },
            nuke: { name: 'Mini Nuke', icon: '‚ò¢Ô∏è', type: 'ability', damage: 250, cooldown: 20000, energy: 100, desc: 'Nuclear strike' },

            // === SUMMONING ===
            summon_wolf: { name: 'Summon Wolf', icon: 'üê∫', type: 'ability', damage: 30, cooldown: 8000, energy: 40, desc: 'Call wolf ally' },
            summon_dragon: { name: 'Summon Dragon', icon: 'üêâ', type: 'ability', damage: 80, cooldown: 15000, energy: 70, desc: 'Dragon attack' },
            summon_golem: { name: 'Summon Golem', icon: 'üóø', type: 'ability', damage: 50, cooldown: 10000, energy: 50, desc: 'Stone guardian' },
            summon_phoenix: { name: 'Summon Phoenix', icon: 'ü¶Ö', type: 'ability', damage: 70, cooldown: 12000, energy: 60, desc: 'Fire bird' },
            summon_demon: { name: 'Summon Demon', icon: 'üëø', type: 'ability', damage: 90, cooldown: 18000, energy: 80, desc: 'Hellspawn' },

            // === ELEMENTAL WEAPONS ===
            flame_sword: { name: 'Flame Sword', icon: 'üî•', type: 'weapon', damage: 55, cooldown: 550, desc: 'Burning blade' },
            frost_axe: { name: 'Frost Axe', icon: 'üßä', type: 'weapon', damage: 58, cooldown: 850, desc: 'Freezing chop' },
            thunder_hammer: { name: 'Thunder Hammer', icon: '‚õàÔ∏è', type: 'weapon', damage: 72, cooldown: 1100, desc: 'Shocking smash' },
            venom_dagger: { name: 'Venom Dagger', icon: 'üêç', type: 'weapon', damage: 25, cooldown: 280, desc: 'Poisoned blade' },
            earth_mace: { name: 'Earth Mace', icon: 'ü™®', type: 'weapon', damage: 62, cooldown: 900, desc: 'Stone crusher' },
            wind_blade: { name: 'Wind Blade', icon: 'üå¨Ô∏è', type: 'weapon', damage: 42, cooldown: 380, desc: 'Swift as wind' },
            shadow_scythe: { name: 'Shadow Scythe', icon: 'üåë', type: 'weapon', damage: 68, cooldown: 800, desc: 'Dark harvest' },
            holy_lance: { name: 'Holy Lance', icon: '‚úùÔ∏è', type: 'weapon', damage: 65, cooldown: 700, desc: 'Divine pierce' }
        };

        const shopItems = [
            // Melee Weapons
            { id: 'axe', price: 150 },
            { id: 'spear', price: 120 },
            { id: 'hammer', price: 300 },
            { id: 'dagger', price: 80 },
            { id: 'katana', price: 250 },
            { id: 'scythe', price: 400 },
            { id: 'mace', price: 200 },
            { id: 'flail', price: 280 },
            { id: 'halberd', price: 350 },
            { id: 'claws', price: 180 },
            { id: 'gauntlet', price: 220 },
            { id: 'chainsaw', price: 500 },
            { id: 'pickaxe', price: 160 },
            { id: 'shovel', price: 90 },
            { id: 'sickle', price: 140 },
            { id: 'nunchucks', price: 170 },
            { id: 'bo_staff', price: 130 },
            { id: 'whip', price: 150 },
            { id: 'anchor', price: 600 },
            { id: 'wrench', price: 190 },
            // Legendary Melee
            { id: 'excalibur', price: 2500 },
            { id: 'mjolnir', price: 3000 },
            { id: 'gungnir', price: 2800 },
            { id: 'kusanagi', price: 2700 },
            // Ranged
            { id: 'bow', price: 200 },
            { id: 'crossbow', price: 350 },
            { id: 'shuriken', price: 100 },
            { id: 'javelin', price: 280 },
            { id: 'boomerang', price: 180 },
            { id: 'kunai', price: 120 },
            { id: 'chakram', price: 250 },
            { id: 'blowdart', price: 80 },
            // Magic Spells
            { id: 'iceball', price: 200 },
            { id: 'lightning', price: 350 },
            { id: 'poison', price: 250 },
            { id: 'laser', price: 500 },
            { id: 'meteor', price: 800 },
            { id: 'tornado', price: 400 },
            { id: 'earthquake', price: 550 },
            { id: 'tsunami', price: 500 },
            { id: 'vortex', price: 700 },
            { id: 'solar', price: 600 },
            { id: 'lunar', price: 550 },
            { id: 'arcane', price: 380 },
            { id: 'nature', price: 320 },
            { id: 'shadow', price: 400 },
            { id: 'holy', price: 450 },
            { id: 'plasma', price: 580 },
            { id: 'gravity', price: 520 },
            { id: 'chain_lightning', price: 360 },
            { id: 'frost_nova', price: 380 },
            { id: 'fire_storm', price: 650 },
            // Legendary Magic
            { id: 'supernova', price: 5000 },
            { id: 'apocalypse', price: 8000 },
            { id: 'genesis', price: 4500 },
            { id: 'oblivion', price: 7000 },
            // Utility
            { id: 'shield', price: 100 },
            { id: 'medkit', price: 75 },
            { id: 'megaHeal', price: 200 },
            { id: 'jumpPad', price: 125 },
            { id: 'speedBoost', price: 150 },
            { id: 'rage', price: 400 },
            { id: 'invisibility', price: 600 },
            { id: 'teleport', price: 450 },
            { id: 'reflect', price: 500 },
            { id: 'lifesteal', price: 700 },
            { id: 'timestop', price: 1500 },
            { id: 'clone', price: 550 },
            { id: 'berserk', price: 800 },
            { id: 'fortify', price: 400 },
            { id: 'regenerate', price: 600 },
            { id: 'energize', price: 300 },
            // Bombs
            { id: 'grenade', price: 250 },
            { id: 'dynamite', price: 400 },
            { id: 'molotov', price: 200 },
            { id: 'flashbang', price: 150 },
            { id: 'smoke_bomb', price: 100 },
            { id: 'cluster_bomb', price: 900 },
            { id: 'nuke', price: 5000 },
            // Summons
            { id: 'summon_wolf', price: 500 },
            { id: 'summon_dragon', price: 2000 },
            { id: 'summon_golem', price: 800 },
            { id: 'summon_phoenix', price: 1500 },
            { id: 'summon_demon', price: 2500 },
            // Elemental Weapons
            { id: 'flame_sword', price: 450 },
            { id: 'frost_axe', price: 480 },
            { id: 'thunder_hammer', price: 650 },
            { id: 'venom_dagger', price: 300 },
            { id: 'earth_mace', price: 520 },
            { id: 'wind_blade', price: 380 },
            { id: 'shadow_scythe', price: 600 },
            { id: 'holy_lance', price: 580 }
        ];
        
        let hotbar = ['sword', 'fireball', null, null, null, null];
        let selectedSlot = 0;
        let itemCooldowns = {};
        
        // Input
        const keys = {};
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let joystickActive = false;
        let joystickX = 0, joystickY = 0;
        
        // Wave
        let currentWave = 1;
        let waveInProgress = false;
        
        // Get terrain height at any position
        function getTerrainHeight(x, z) {
            let height = 0;
            height += Math.sin(x * 0.02) * Math.cos(z * 0.02) * 3; // Large hills
            height += Math.sin(x * 0.05) * Math.cos(z * 0.04) * 1.5; // Medium bumps
            height += Math.sin(x * 0.1 + z * 0.1) * 0.3; // Small details
            height += Math.sin(x * 0.15 + z * 0.08) * 0.15; // Micro details

            const distFromCenter = Math.sqrt(x * x + z * z);
            if (distFromCenter < 30) {
                height *= distFromCenter / 30;
            }

            return height;
        }
        
        function init() {
            playerState = {
                position: new THREE.Vector3(0, 1.7, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: { x: 0, y: 0 },
                health: 100,
                maxHealth: 100,
                energy: 100,
                maxEnergy: 100,
                speed: 0.03,
                sprintSpeed: 0.05,
                defense: 5,
                isGrounded: true,
                score: 0,
                kills: 0,
                // Dash ability
                isDashing: false,
                dashTime: 0,
                dashCooldown: 0,
                dashDir: new THREE.Vector3(),
                // Slide ability
                isSliding: false,
                slideTime: 0,
                slideCooldown: 0,
                slideDir: new THREE.Vector3(),
                // Slow effect from enemies
                slowed: false,
                slowTime: 0,
                // Double jump
                jumpsRemaining: 2,
                maxJumps: 2,
                // Wall running
                isWallRunning: false,
                wallRunTime: 0,
                wallRunDir: new THREE.Vector3(),
                wallNormal: new THREE.Vector3(),
                wallRunCooldown: 0
            };
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x4A90D9);
            scene.fog = new THREE.FogExp2(0x5A9AD9, 0.004);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.copy(playerState.position);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // Enhanced realistic lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.35);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfff5e0, 1.0);
            sunLight.position.set(60, 100, 40);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 5;
            sunLight.shadow.camera.far = 350;
            sunLight.shadow.camera.left = -60;
            sunLight.shadow.camera.right = 60;
            sunLight.shadow.camera.top = 60;
            sunLight.shadow.camera.bottom = -60;
            sunLight.shadow.bias = -0.00005;
            scene.add(sunLight);
            
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d5c2f, 0.5);
            scene.add(hemiLight);
            
            // Ground - realistic grass with hills (higher resolution)
            const groundGeo = new THREE.PlaneGeometry(250, 250, 180, 180);
            const positions = groundGeo.attributes.position;
            const colors = [];

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                // Create rolling hills with more variation
                let height = 0;
                height += Math.sin(x * 0.02) * Math.cos(y * 0.02) * 3; // Large hills
                height += Math.sin(x * 0.05) * Math.cos(y * 0.04) * 1.5; // Medium bumps
                height += Math.sin(x * 0.1 + y * 0.1) * 0.3; // Small details
                height += Math.sin(x * 0.15 + y * 0.08) * 0.15; // Micro details

                // Flatten area near spawn
                const distFromCenter = Math.sqrt(x * x + y * y);
                if (distFromCenter < 30) {
                    height *= distFromCenter / 30;
                }

                positions.setZ(i, height);

                // Vertex colors for ground variation - vibrant and lush
                const grassBase = new THREE.Color(0x3D8B40);
                const grassDark = new THREE.Color(0x1B5E20);
                const grassLight = new THREE.Color(0x66BB6A);
                const dirt = new THREE.Color(0x795548);

                // Mix colors based on position and height
                let color = grassBase.clone();
                const noise = Math.sin(x * 0.3) * Math.cos(y * 0.25) * 0.5 + 0.5;
                const heightFactor = (height + 3) / 6;

                if (noise > 0.7) {
                    color.lerp(grassLight, (noise - 0.7) * 2);
                } else if (noise < 0.3) {
                    color.lerp(grassDark, (0.3 - noise) * 2);
                }

                // Add dirt patches
                const dirtNoise = Math.sin(x * 0.08 + 1.5) * Math.cos(y * 0.12 + 2.3);
                if (dirtNoise > 0.6) {
                    color.lerp(dirt, (dirtNoise - 0.6) * 1.5);
                }

                // Darken valleys, lighten peaks
                color.lerp(grassDark, Math.max(0, -heightFactor * 0.3));
                color.lerp(grassLight, Math.max(0, heightFactor * 0.2));

                colors.push(color.r, color.g, color.b);
            }

            groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.92,
                metalness: 0,
                flatShading: false
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Village center cobblestone area - follows terrain
            const cobbleGeo = new THREE.PlaneGeometry(36, 36, 24, 24);
            const cobblePositions = cobbleGeo.attributes.position;
            const cobbleCenter = { x: 0, z: 12 };

            // Adjust vertices to follow terrain and create circular shape
            for (let i = 0; i < cobblePositions.count; i++) {
                const x = cobblePositions.getX(i) + cobbleCenter.x;
                const y = cobblePositions.getY(i) + cobbleCenter.z;
                const distFromCenter = Math.sqrt(x * x + (y - cobbleCenter.z) * (y - cobbleCenter.z));

                // Get terrain height at this point
                const terrainHeight = getTerrainHeight(x, y);

                // Set Z (which becomes Y after rotation) to terrain height + small offset
                cobblePositions.setZ(i, terrainHeight + 0.05);

                // Fade out vertices outside the circular area
                if (distFromCenter > 16) {
                    cobblePositions.setZ(i, terrainHeight - 0.5); // Hide outside circle
                }
            }
            cobbleGeo.computeVertexNormals();

            const cobbleMat = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 0.85,
                metalness: 0.1
            });
            const cobble = new THREE.Mesh(cobbleGeo, cobbleMat);
            cobble.rotation.x = -Math.PI / 2;
            cobble.position.set(0, 0, 0);
            cobble.receiveShadow = true;
            scene.add(cobble);

            // Cobblestone details (individual stones) - follow terrain
            for (let s = 0; s < 80; s++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 16;
                const stoneSize = 0.3 + Math.random() * 0.4;
                const stoneGeo = new THREE.CylinderGeometry(stoneSize, stoneSize * 0.9, 0.08, 6);
                const stoneMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.35 + Math.random() * 0.2),
                    roughness: 0.9
                });
                const stone = new THREE.Mesh(stoneGeo, stoneMat);
                const stoneX = Math.cos(angle) * radius;
                const stoneZ = 12 + Math.sin(angle) * radius;
                const stoneY = getTerrainHeight(stoneX, stoneZ) + 0.06;
                stone.position.set(stoneX, stoneY, stoneZ);
                stone.rotation.y = Math.random() * Math.PI;
                stone.receiveShadow = true;
                scene.add(stone);
            }

            // Dirt paths (multiple)
            const pathMat = new THREE.MeshStandardMaterial({ color: 0x7a6355, roughness: 0.95 });

            // Main path (north-south)
            const pathGeo1 = new THREE.PlaneGeometry(4, 150);
            const path1 = new THREE.Mesh(pathGeo1, pathMat);
            path1.rotation.x = -Math.PI / 2;
            path1.position.y = 0.02;
            path1.receiveShadow = true;
            scene.add(path1);

            // East-west path
            const pathGeo2 = new THREE.PlaneGeometry(100, 3.5);
            const path2 = new THREE.Mesh(pathGeo2, pathMat);
            path2.rotation.x = -Math.PI / 2;
            path2.position.set(0, 0.02, 12);
            path2.receiveShadow = true;
            scene.add(path2);

            // Path to church
            const pathGeo3 = new THREE.PlaneGeometry(3, 40);
            const path3 = new THREE.Mesh(pathGeo3, pathMat);
            path3.rotation.x = -Math.PI / 2;
            path3.rotation.z = -0.4;
            path3.position.set(20, 0.02, -5);
            path3.receiveShadow = true;
            scene.add(path3);

            // Scatter small rocks on ground
            for (let r = 0; r < 50; r++) {
                const rx = (Math.random() - 0.5) * 200;
                const rz = (Math.random() - 0.5) * 200;
                const terrainY = getTerrainHeight(rx, rz);
                const rockSize = 0.1 + Math.random() * 0.15;
                const smallRock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(rockSize, 0),
                    new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.08, 0.1, 0.3 + Math.random() * 0.15),
                        roughness: 0.95
                    })
                );
                smallRock.position.set(rx, terrainY + rockSize * 0.3, rz);
                smallRock.rotation.set(Math.random(), Math.random(), Math.random());
                smallRock.castShadow = true;
                scene.add(smallRock);
            }
            
            createEnvironment();
            createBuildings();
            
            const playerGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.7, 16);
            const playerMat = new THREE.MeshStandardMaterial({ visible: false });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.copy(playerState.position);
            scene.add(player);
            
            // Create realistic 3D sword
            const swordGroup = new THREE.Group();

            // Blade materials - polished steel with slight blue tint
            const bladeMat = new THREE.MeshStandardMaterial({
                color: 0xd8dce3,
                metalness: 0.98,
                roughness: 0.1,
                envMapIntensity: 1.2
            });
            const bladeEdgeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.05
            });

            // Main blade body - tapered
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(-0.035, 0);
            bladeShape.lineTo(-0.03, 0.7);
            bladeShape.lineTo(0, 0.85);
            bladeShape.lineTo(0.03, 0.7);
            bladeShape.lineTo(0.035, 0);
            bladeShape.lineTo(-0.035, 0);

            const extrudeSettings = { depth: 0.012, bevelEnabled: true, bevelThickness: 0.002, bevelSize: 0.002, bevelSegments: 2 };
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, extrudeSettings);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(0, 0.1, -0.006);
            blade.castShadow = true;
            swordGroup.add(blade);

            // Blade fuller (blood groove) - adds realism
            const fullerGeo = new THREE.BoxGeometry(0.015, 0.55, 0.003);
            const fullerMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.9, roughness: 0.3 });
            const fuller = new THREE.Mesh(fullerGeo, fullerMat);
            fuller.position.set(0, 0.4, 0.008);
            swordGroup.add(fuller);

            // Blade edge highlight
            const edgeGeo = new THREE.BoxGeometry(0.002, 0.7, 0.015);
            const leftEdge = new THREE.Mesh(edgeGeo, bladeEdgeMat);
            leftEdge.position.set(-0.033, 0.45, 0);
            swordGroup.add(leftEdge);
            const rightEdge = new THREE.Mesh(edgeGeo, bladeEdgeMat);
            rightEdge.position.set(0.033, 0.45, 0);
            swordGroup.add(rightEdge);

            // Crossguard (ornate)
            const guardMat = new THREE.MeshStandardMaterial({
                color: 0xc9a227,
                metalness: 0.85,
                roughness: 0.25
            });
            const guardCoreMat = new THREE.MeshStandardMaterial({
                color: 0x8b7355,
                metalness: 0.7,
                roughness: 0.4
            });

            // Main guard bar
            const guardGeo = new THREE.BoxGeometry(0.22, 0.035, 0.04);
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = 0.08;
            guard.castShadow = true;
            swordGroup.add(guard);

            // Guard end caps (quillons)
            const quilGeo = new THREE.SphereGeometry(0.025, 10, 10);
            const leftQuil = new THREE.Mesh(quilGeo, guardMat);
            leftQuil.position.set(-0.11, 0.08, 0);
            swordGroup.add(leftQuil);
            const rightQuil = new THREE.Mesh(quilGeo, guardMat);
            rightQuil.position.set(0.11, 0.08, 0);
            swordGroup.add(rightQuil);

            // Ricasso (unsharpened blade section)
            const ricassoGeo = new THREE.BoxGeometry(0.045, 0.06, 0.015);
            const ricasso = new THREE.Mesh(ricassoGeo, bladeMat);
            ricasso.position.set(0, 0.11, 0);
            swordGroup.add(ricasso);

            // Handle with leather wrapping
            const handleMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.85,
                metalness: 0.05
            });

            // Handle core
            const handleGeo = new THREE.CylinderGeometry(0.022, 0.026, 0.22, 12);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.06;
            handle.castShadow = true;
            swordGroup.add(handle);

            // Leather wrapping rings
            const wrapMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 });
            for (let i = 0; i < 6; i++) {
                const wrapGeo = new THREE.TorusGeometry(0.028, 0.004, 8, 16);
                const wrap = new THREE.Mesh(wrapGeo, wrapMat);
                wrap.position.y = -0.14 + i * 0.028;
                wrap.rotation.x = Math.PI / 2;
                swordGroup.add(wrap);
            }

            // Pommel (weighted end)
            const pommelGeo = new THREE.SphereGeometry(0.032, 12, 12);
            const pommel = new THREE.Mesh(pommelGeo, guardMat);
            pommel.position.y = -0.19;
            pommel.castShadow = true;
            swordGroup.add(pommel);

            // Pommel cap detail
            const capGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.015, 8);
            const cap = new THREE.Mesh(capGeo, guardMat);
            cap.position.y = -0.22;
            swordGroup.add(cap);

            // Gem in pommel
            const gemGeo = new THREE.OctahedronGeometry(0.012, 0);
            const gemMat = new THREE.MeshStandardMaterial({
                color: 0xff0033,
                emissive: 0xff0022,
                emissiveIntensity: 0.6,
                metalness: 0.3,
                roughness: 0.1
            });
            const gem = new THREE.Mesh(gemGeo, gemMat);
            gem.position.y = -0.19;
            gem.position.z = 0.03;
            swordGroup.add(gem);

            swordMesh = swordGroup;
            swordMesh.visible = false;
            scene.add(swordMesh);
            
            setupMinimap();

            // Wait for cloud data then sync hotbar
            const waitForCloud = () => {
                if (cloudDataLoaded) {
                    syncHotbarWithInventory();
                    setupHotbar();
                    generateSettingsUI();
                    updateShopUI();
                } else {
                    setTimeout(waitForCloud, 50);
                }
            };
            waitForCloud();
        }
        
        function createEnvironment() {
            colliders = [];
            
            // Trees - realistic
            for (let i = 0; i < 40; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                
                if (Math.abs(x) < 25 && Math.abs(z) < 25) continue;
                if (Math.abs(x) < 4) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const treeHeight = 5 + Math.random() * 3;
                const trunkRadius = 0.25 + Math.random() * 0.15;
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, treeHeight * 0.4, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.set(x, terrainY + treeHeight * 0.2, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                colliders.push({
                    type: 'cylinder',
                    position: new THREE.Vector3(x, terrainY, z),
                    radius: trunkRadius + 0.2,
                    canAutoJump: false
                });
                
                // Foliage layers
                for (let j = 0; j < 3; j++) {
                    const foliageRadius = (1.5 - j * 0.3) * (0.8 + Math.random() * 0.2);
                    const foliageGeo = new THREE.ConeGeometry(foliageRadius, treeHeight * 0.2, 8);
                    const foliageMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.28 + Math.random() * 0.05, 0.45, 0.28 + Math.random() * 0.06),
                        roughness: 0.85
                    });
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.set(x, terrainY + treeHeight * (0.4 + j * 0.14), z);
                    foliage.castShadow = true;
                    scene.add(foliage);
                }
            }
            
            // Rocks - realistic flat orientation
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                
                if (Math.abs(x) < 18 && Math.abs(z) < 18) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const rockSize = 0.3 + Math.random() * 0.8;
                const rockGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(0.4 + Math.random() * 0.15, 0.4 + Math.random() * 0.1, 0.38),
                    roughness: 0.95,
                    flatShading: true
                });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(x, terrainY + rockSize * 0.3, z);
                // REALISTIC: rocks lie flat, only slight random rotation
                rock.rotation.set(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.3
                );
                rock.scale.set(1 + Math.random() * 0.4, 0.4 + Math.random() * 0.3, 1 + Math.random() * 0.4);
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                
                colliders.push({
                    type: 'sphere',
                    position: new THREE.Vector3(x, terrainY + rockSize * 0.2, z),
                    radius: rockSize * 0.6,
                    canAutoJump: true,
                    jumpHeight: rockSize * 0.3
                });
            }
            
            // Grass tufts
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 120;
                const z = (Math.random() - 0.5) * 120;
                const terrainY = getTerrainHeight(x, z);
                
                const grassGeo = new THREE.PlaneGeometry(0.12, 0.3 + Math.random() * 0.2);
                const grassMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.25 + Math.random() * 0.05, 0.5, 0.32),
                    side: THREE.DoubleSide
                });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.position.set(x, terrainY + 0.15, z);
                grass.rotation.y = Math.random() * Math.PI;
                grass.rotation.x = -0.1;
                scene.add(grass);
            }
        }
        
        function createBuildings() {
            buildings = [];

            const buildingData = [
                // Village center
                { x: 20, z: 0, type: 'house' },
                { x: -20, z: 0, type: 'shop' },
                { x: 20, z: 25, type: 'barn' },
                { x: -20, z: -25, type: 'tower' },
                // New buildings
                { x: 0, z: 35, type: 'tavern' },
                { x: -35, z: 15, type: 'blacksmith' },
                { x: 35, z: -15, type: 'church' },
                { x: -10, z: -40, type: 'windmill' },
                { x: 45, z: 20, type: 'watchtower' },
                { x: -45, z: -10, type: 'house' },
                { x: 30, z: 45, type: 'stable' },
                { x: -30, z: 40, type: 'shop' },
                // Outer buildings
                { x: 55, z: -35, type: 'ruins' },
                { x: -55, z: 35, type: 'cottage' },
                { x: 60, z: 50, type: 'watchtower' },
                { x: -60, z: -50, type: 'barn' }
            ];

            buildingData.forEach(b => {
                const terrainY = getTerrainHeight(b.x, b.z);
                createBuilding(b.x, b.z, b.type, terrainY);
            });

            // Add village well in center
            createWell(0, 15);

            // Add market stalls
            createMarketStall(-8, 8);
            createMarketStall(-4, 8);
            createMarketStall(4, 8);

            // Add fences
            createFence(-15, 25, 20, 0);
            createFence(15, 25, 20, 0);
            createFence(-25, 20, 15, Math.PI / 2);
        }

        function createWell(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const wellGroup = new THREE.Group();

            // Stone base
            const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.8, 12);
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeo, stoneMat);
            base.position.y = 0.4;
            base.castShadow = true;
            wellGroup.add(base);

            // Inner hole (dark)
            const holeGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12);
            const holeMat = new THREE.MeshStandardMaterial({ color: 0x111122 });
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.position.y = 0.82;
            wellGroup.add(hole);

            // Wooden frame posts
            const postMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 });
            for (let i = 0; i < 2; i++) {
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.5, 0.15), postMat);
                post.position.set(i === 0 ? -1 : 1, 1.6, 0);
                post.castShadow = true;
                wellGroup.add(post);
            }

            // Roof beam
            const beam = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 0.2), postMat);
            beam.position.y = 2.9;
            wellGroup.add(beam);

            // Roof
            const roofGeo = new THREE.BoxGeometry(2.8, 0.1, 1.5);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3.1;
            roof.rotation.x = 0.15;
            wellGroup.add(roof);

            // Bucket
            const bucketGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 8);
            const bucketMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const bucket = new THREE.Mesh(bucketGeo, bucketMat);
            bucket.position.set(0, 1.5, 0);
            wellGroup.add(bucket);

            // Rope
            const ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
            const ropeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const rope = new THREE.Mesh(ropeGeo, ropeMat);
            rope.position.set(0, 2.2, 0);
            wellGroup.add(rope);

            wellGroup.position.set(x, terrainY, z);
            scene.add(wellGroup);

            // Add collision for well
            colliders.push({
                type: 'cylinder',
                position: new THREE.Vector3(x, terrainY, z),
                radius: 1.5,
                canAutoJump: false
            });
        }

        function createMarketStall(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const stallGroup = new THREE.Group();

            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1.2), tableMat);
            table.position.y = 1;
            table.castShadow = true;
            stallGroup.add(table);

            // Legs
            for (let lx = -0.8; lx <= 0.8; lx += 1.6) {
                for (let lz = -0.4; lz <= 0.4; lz += 0.8) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.1), tableMat);
                    leg.position.set(lx, 0.5, lz);
                    stallGroup.add(leg);
                }
            }

            // Canopy poles
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            for (let px = -0.9; px <= 0.9; px += 1.8) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2, 8), poleMat);
                pole.position.set(px, 2, -0.5);
                stallGroup.add(pole);
            }

            // Canopy
            const canopyColors = [0xcc3333, 0x3366cc, 0x33aa33, 0xcccc33];
            const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
            const canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.9, side: THREE.DoubleSide });
            const canopy = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 1.5), canopyMat);
            canopy.position.set(0, 2.8, 0);
            canopy.rotation.x = -0.3;
            stallGroup.add(canopy);

            // Goods on table (random items)
            const goodsColors = [0xff6600, 0xffff00, 0x00ff00, 0xff0000, 0x8B4513];
            for (let g = 0; g < 5; g++) {
                const goodGeo = Math.random() > 0.5 ?
                    new THREE.SphereGeometry(0.1, 8, 8) :
                    new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const goodMat = new THREE.MeshStandardMaterial({ color: goodsColors[g] });
                const good = new THREE.Mesh(goodGeo, goodMat);
                good.position.set(-0.6 + g * 0.3, 1.15, (Math.random() - 0.5) * 0.6);
                stallGroup.add(good);
            }

            stallGroup.position.set(x, terrainY, z);
            scene.add(stallGroup);

            // Add collision for market stall
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x, terrainY, z),
                width: 2.2,
                depth: 1.4,
                canAutoJump: true
            });
        }

        function createFence(x, z, length, rotation) {
            const terrainY = getTerrainHeight(x, z);
            const fenceGroup = new THREE.Group();
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });

            const postCount = Math.floor(length / 2);
            for (let i = 0; i < postCount; i++) {
                // Post
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.2, 0.12), fenceMat);
                post.position.set(i * 2 - length / 2 + 1, 0.6, 0);
                post.castShadow = true;
                fenceGroup.add(post);

                // Horizontal beams
                if (i < postCount - 1) {
                    const beam1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam1.position.set(i * 2 - length / 2 + 2, 0.9, 0);
                    fenceGroup.add(beam1);

                    const beam2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam2.position.set(i * 2 - length / 2 + 2, 0.4, 0);
                    fenceGroup.add(beam2);
                }
            }

            fenceGroup.rotation.y = rotation;
            fenceGroup.position.set(x, terrainY, z);
            scene.add(fenceGroup);

            // Add collision for fence (long thin box)
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x, terrainY, z),
                width: Math.abs(cos) * length + Math.abs(sin) * 0.3,
                depth: Math.abs(sin) * length + Math.abs(cos) * 0.3,
                canAutoJump: true
            });
        }

        function createBuilding(x, z, type, terrainY) {
            const building = new THREE.Group();
            
            let width, depth, height, wallColor, roofColor;
            
            let isSpecial = false;

            switch(type) {
                case 'house':
                    width = 7; depth = 5; height = 3.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x8B4513;
                    break;
                case 'shop':
                    width = 8; depth = 6; height = 3.5;
                    wallColor = 0xF5DEB3;
                    roofColor = 0x654321;
                    break;
                case 'barn':
                    width = 10; depth = 7; height = 4;
                    wallColor = 0xCD853F;
                    roofColor = 0x8B0000;
                    break;
                case 'tower':
                    width = 5; depth = 5; height = 8;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'tavern':
                    width = 12; depth = 8; height = 4.5;
                    wallColor = 0xDEB887;
                    roofColor = 0x4a3728;
                    break;
                case 'blacksmith':
                    width = 9; depth = 7; height = 3.5;
                    wallColor = 0x696969;
                    roofColor = 0x2F2F2F;
                    break;
                case 'church':
                    width = 10; depth = 15; height = 7;
                    wallColor = 0xE8E8E8;
                    roofColor = 0x4a4a5a;
                    break;
                case 'windmill':
                    width = 6; depth = 6; height = 10;
                    wallColor = 0xF5F5DC;
                    roofColor = 0x8B4513;
                    isSpecial = true;
                    break;
                case 'watchtower':
                    width = 4; depth = 4; height = 12;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'stable':
                    width = 12; depth = 8; height = 3;
                    wallColor = 0x8B7355;
                    roofColor = 0x654321;
                    break;
                case 'ruins':
                    width = 8; depth = 8; height = 2;
                    wallColor = 0x696969;
                    roofColor = 0x505050;
                    isSpecial = true;
                    break;
                case 'cottage':
                    width = 5; depth = 4; height = 2.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x556B2F;
                    break;
                default:
                    width = 6; depth = 5; height = 3;
                    wallColor = 0xBDB76B;
                    roofColor = 0x8B4513;
            }
            
            // Calculate terrain heights at corners for foundation
            const corners = [
                { cx: x - width/2, cz: z - depth/2 },
                { cx: x + width/2, cz: z - depth/2 },
                { cx: x - width/2, cz: z + depth/2 },
                { cx: x + width/2, cz: z + depth/2 }
            ];
            
            let minTerrainY = terrainY;
            let maxTerrainY = terrainY;
            corners.forEach(c => {
                const h = getTerrainHeight(c.cx, c.cz);
                minTerrainY = Math.min(minTerrainY, h);
                maxTerrainY = Math.max(maxTerrainY, h);
            });
            
            // Foundation height to cover the slope
            const foundationHeight = maxTerrainY - minTerrainY + 0.5;
            const baseY = minTerrainY;
            
            // Create adaptive foundation using multiple segments
            const foundationMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            
            // Create foundation segments to match terrain
            const segmentsX = 4;
            const segmentsZ = 4;
            const segWidth = width / segmentsX;
            const segDepth = depth / segmentsZ;
            
            for (let sx = 0; sx < segmentsX; sx++) {
                for (let sz = 0; sz < segmentsZ; sz++) {
                    const segX = -width/2 + segWidth/2 + sx * segWidth;
                    const segZ = -depth/2 + segDepth/2 + sz * segDepth;
                    const worldX = x + segX;
                    const worldZ = z + segZ;
                    const segTerrainY = getTerrainHeight(worldX, worldZ);
                    
                    // Height from terrain to building base
                    const segFoundHeight = (baseY + foundationHeight) - segTerrainY + 0.1;
                    
                    if (segFoundHeight > 0.05) {
                        const foundGeo = new THREE.BoxGeometry(segWidth + 0.05, segFoundHeight, segDepth + 0.05);
                        const foundSeg = new THREE.Mesh(foundGeo, foundationMat);
                        foundSeg.position.set(segX, segTerrainY - baseY + segFoundHeight/2, segZ);
                        foundSeg.castShadow = true;
                        foundSeg.receiveShadow = true;
                        building.add(foundSeg);
                    }
                }
            }
            
            // Building base level (on top of foundation)
            const buildingBaseY = foundationHeight;
            
            const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.85 });
            const wallThickness = 0.25;
            const doorWidth = 1.4;
            const doorHeight = 2.2;
            
            // Front wall - LEFT of door
            const frontLeftGeo = new THREE.BoxGeometry((width - doorWidth) / 2, height, wallThickness);
            const frontLeft = new THREE.Mesh(frontLeftGeo, wallMat);
            frontLeft.position.set(-(width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontLeft.castShadow = true;
            frontLeft.receiveShadow = true;
            building.add(frontLeft);
            
            // Front wall - RIGHT of door
            const frontRight = new THREE.Mesh(frontLeftGeo, wallMat);
            frontRight.position.set((width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontRight.castShadow = true;
            frontRight.receiveShadow = true;
            building.add(frontRight);
            
            // Front wall - ABOVE door
            const frontTopGeo = new THREE.BoxGeometry(doorWidth, height - doorHeight, wallThickness);
            const frontTop = new THREE.Mesh(frontTopGeo, wallMat);
            frontTop.position.set(0, buildingBaseY + height - (height - doorHeight)/2, depth/2);
            frontTop.castShadow = true;
            building.add(frontTop);
            
            // Back wall (solid)
            const backWallGeo = new THREE.BoxGeometry(width, height, wallThickness);
            const backWall = new THREE.Mesh(backWallGeo, wallMat);
            backWall.position.set(0, buildingBaseY + height/2, -depth/2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            building.add(backWall);
            
            // Side walls
            const sideWallGeo = new THREE.BoxGeometry(wallThickness, height, depth);
            const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
            leftWall.position.set(-width/2, buildingBaseY + height/2, 0);
            leftWall.castShadow = true;
            building.add(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
            rightWall.position.set(width/2, buildingBaseY + height/2, 0);
            rightWall.castShadow = true;
            building.add(rightWall);
            
            // Roof
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.8 });
            if (type === 'tower') {
                const roofGeo = new THREE.ConeGeometry(width * 0.75, height * 0.4, 4);
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(0, buildingBaseY + height + height * 0.2, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                building.add(roof);
            } else {
                const roofGeo = new THREE.BoxGeometry(width + 0.6, 0.3, depth + 0.6);
                const roofBase = new THREE.Mesh(roofGeo, roofMat);
                roofBase.position.set(0, buildingBaseY + height, 0);
                roofBase.castShadow = true;
                building.add(roofBase);
                
                // Pitched roof
                const pitchGeo = new THREE.CylinderGeometry(0, depth * 0.6, height * 0.35, 4);
                const pitch = new THREE.Mesh(pitchGeo, roofMat);
                pitch.position.set(0, buildingBaseY + height + height * 0.17, 0);
                pitch.rotation.y = Math.PI / 4;
                pitch.castShadow = true;
                building.add(pitch);
            }
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(width - 0.5, depth - 0.5);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = buildingBaseY + 0.05;
            floor.receiveShadow = true;
            building.add(floor);
            
            // Interior
            createInterior(building, width, depth, height, type, buildingBaseY);
            
            // Door frame
            const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0x4A3C31 });
            const doorFrameGeo = new THREE.BoxGeometry(doorWidth + 0.2, 0.15, 0.3);
            const doorTop = new THREE.Mesh(doorFrameGeo, doorFrameMat);
            doorTop.position.set(0, buildingBaseY + doorHeight, depth/2 + 0.1);
            building.add(doorTop);
            
            // Windows
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.5
            });
            
            [-width/3, width/3].forEach(wx => {
                const windowGeo = new THREE.BoxGeometry(0.8, 0.8, 0.15);
                const win = new THREE.Mesh(windowGeo, windowMat);
                win.position.set(wx, buildingBaseY + height * 0.55, depth/2 + 0.15);
                building.add(win);
            });
            
            // Add special features for specific building types
            if (type === 'windmill') {
                // Windmill blades
                const bladeGroup = new THREE.Group();
                const bladeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 });
                for (let b = 0; b < 4; b++) {
                    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.1), bladeMat);
                    blade.position.y = 2;
                    blade.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(blade);
                    // Blade frame
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3.5, 0.05), bladeMat);
                    frame.position.set(0.15, 1.75, 0);
                    frame.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(frame);
                }
                bladeGroup.position.set(0, buildingBaseY + height * 0.7, depth / 2 + 0.5);
                building.add(bladeGroup);
                // Store for animation
                building.userData.blades = bladeGroup;
            }

            if (type === 'church') {
                // Church steeple
                const steepleGeo = new THREE.ConeGeometry(1.5, 5, 4);
                const steeepleMat = new THREE.MeshStandardMaterial({ color: roofColor, metalness: 0.3 });
                const steeple = new THREE.Mesh(steepleGeo, steeepleMat);
                steeple.position.set(0, buildingBaseY + height + 3.5, -depth / 3);
                steeple.rotation.y = Math.PI / 4;
                building.add(steeple);
                // Cross
                const crossMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), crossMat);
                crossV.position.set(0, buildingBaseY + height + 6.5, -depth / 3);
                building.add(crossV);
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.15), crossMat);
                crossH.position.set(0, buildingBaseY + height + 6.2, -depth / 3);
                building.add(crossH);
                // Rose window
                const roseGeo = new THREE.CircleGeometry(1.2, 16);
                const roseMat = new THREE.MeshStandardMaterial({
                    color: 0x4169E1,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const rose = new THREE.Mesh(roseGeo, roseMat);
                rose.position.set(0, buildingBaseY + height * 0.65, depth / 2 + 0.16);
                building.add(rose);
            }

            if (type === 'blacksmith') {
                // Chimney with smoke
                const chimneyGeo = new THREE.BoxGeometry(1.2, 3, 1.2);
                const chimneyMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9 });
                const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                chimney.position.set(width / 3, buildingBaseY + height + 1, -depth / 3);
                building.add(chimney);
                // Anvil outside
                const anvilBase = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.4, 0.4),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 })
                );
                anvilBase.position.set(width / 2 + 1.5, buildingBaseY + 0.2, 0);
                building.add(anvilBase);
                const anvilTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.15, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.95 })
                );
                anvilTop.position.set(width / 2 + 1.5, buildingBaseY + 0.48, 0);
                building.add(anvilTop);
                // Forge glow
                const forgeGlow = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 0.5),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 })
                );
                forgeGlow.position.set(-width / 3, buildingBaseY + 0.5, depth / 2 - 0.5);
                building.add(forgeGlow);
            }

            if (type === 'tavern') {
                // Tavern sign
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                );
                signPost.position.set(width / 2 + 0.5, buildingBaseY + 2.5, depth / 2);
                building.add(signPost);
                const signBoard = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.8, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                signBoard.position.set(width / 2 + 0.5, buildingBaseY + 3.2, depth / 2 + 0.4);
                building.add(signBoard);
                // Barrels outside
                for (let br = 0; br < 3; br++) {
                    const barrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.3, 0.7, 12),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    barrel.position.set(-width / 2 - 0.8, buildingBaseY + 0.35, depth / 4 - br * 0.8);
                    building.add(barrel);
                }
            }

            if (type === 'stable') {
                // Horse stall dividers
                const stallMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                for (let s = 0; s < 4; s++) {
                    const divider = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, depth - 1), stallMat);
                    divider.position.set(-width / 2 + 2.5 + s * 2.5, buildingBaseY + 1, 0);
                    building.add(divider);
                }
                // Hay bales
                const hayMat = new THREE.MeshStandardMaterial({ color: 0xDAA520 });
                for (let h = 0; h < 3; h++) {
                    const hay = new THREE.Mesh(new THREE.BoxGeometry(1, 0.6, 0.8), hayMat);
                    hay.position.set(width / 2 - 1.5, buildingBaseY + 0.3 + h * 0.5, -depth / 3 + h * 0.3);
                    hay.rotation.y = h * 0.2;
                    building.add(hay);
                }
            }

            if (type === 'ruins') {
                // Broken walls scattered
                const ruinMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 1 });
                for (let r = 0; r < 8; r++) {
                    const rubble = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5 + Math.random(), 0.3 + Math.random() * 0.5, 0.5 + Math.random()),
                        ruinMat
                    );
                    rubble.position.set(
                        (Math.random() - 0.5) * width,
                        buildingBaseY + 0.2,
                        (Math.random() - 0.5) * depth
                    );
                    rubble.rotation.set(Math.random() * 0.3, Math.random() * Math.PI, Math.random() * 0.3);
                    building.add(rubble);
                }
                // Partial standing wall
                const wallPiece = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 0.4), ruinMat);
                wallPiece.position.set(-width / 4, buildingBaseY + 1.25, depth / 3);
                wallPiece.rotation.y = 0.2;
                building.add(wallPiece);
            }

            if (type === 'watchtower') {
                // Platform at top
                const platformGeo = new THREE.BoxGeometry(width + 1.5, 0.3, depth + 1.5);
                const platformMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const platform = new THREE.Mesh(platformGeo, platformMat);
                platform.position.y = buildingBaseY + height - 0.5;
                building.add(platform);
                // Battlements
                const bMat = new THREE.MeshStandardMaterial({ color: wallColor });
                for (let bx = -1; bx <= 1; bx++) {
                    for (let bz = -1; bz <= 1; bz++) {
                        if (Math.abs(bx) + Math.abs(bz) === 2) {
                            const battlement = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.8), bMat);
                            battlement.position.set(bx * (width / 2 + 0.4), buildingBaseY + height + 0.2, bz * (depth / 2 + 0.4));
                            building.add(battlement);
                        }
                    }
                }
                // Flag
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), poleMat);
                pole.position.set(0, buildingBaseY + height + 1.25, 0);
                building.add(pole);
                const flagMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.8), flagMat);
                flag.position.set(0.6, buildingBaseY + height + 2, 0);
                building.add(flag);
            }

            building.position.set(x, baseY, z);
            scene.add(building);
            
            // Collision - walls only (not door opening)
            const collisionY = baseY + buildingBaseY;
            
            // Left wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Right wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Back wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x, collisionY, z - depth/2),
                width: width + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall LEFT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall RIGHT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            
            buildings.push({ x, z, width, depth, height, type, baseY });
        }
        
        function createInterior(building, width, depth, height, type, buildingBaseY) {
            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const tableGeo = new THREE.BoxGeometry(1.6, 0.08, 0.8);
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, buildingBaseY + 0.7, 0);
            table.castShadow = true;
            building.add(table);
            
            // Table legs
            const legGeo = new THREE.BoxGeometry(0.08, 0.7, 0.08);
            [[-0.7, -0.3], [-0.7, 0.3], [0.7, -0.3], [0.7, 0.3]].forEach(([lx, lz]) => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(lx, buildingBaseY + 0.35, lz);
                building.add(leg);
            });
            
            // Chair
            const chairMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.04, 0.4), chairMat);
            chairSeat.position.set(-1.3, buildingBaseY + 0.45, 0);
            building.add(chairSeat);
            
            const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.04), chairMat);
            chairBack.position.set(-1.3, buildingBaseY + 0.7, -0.2);
            building.add(chairBack);
            
            // Fireplace for house
            if (type === 'house' || type === 'shop') {
                const fireplaceGeo = new THREE.BoxGeometry(1.2, 1, 0.4);
                const fireplaceMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
                const fireplace = new THREE.Mesh(fireplaceGeo, fireplaceMat);
                fireplace.position.set(0, buildingBaseY + 0.5, -depth/2 + 0.4);
                building.add(fireplace);
                
                const fireLight = new THREE.PointLight(0xff6600, 0.6, 4);
                fireLight.position.set(0, buildingBaseY + 0.4, -depth/2 + 0.6);
                building.add(fireLight);
            }
            
            // Ceiling light
            const lightGeo = new THREE.CylinderGeometry(0.25, 0.3, 0.15, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xB8860B });
            const ceilingLight = new THREE.Mesh(lightGeo, lightMat);
            ceilingLight.position.set(0, buildingBaseY + height - 0.4, 0);
            building.add(ceilingLight);
            
            const interiorLight = new THREE.PointLight(0xffee88, 0.5, 6);
            interiorLight.position.set(0, buildingBaseY + height - 0.5, 0);
            building.add(interiorLight);
        }
        
        function generateSettingsUI() {
            const container = document.getElementById('settingsContent');
            container.innerHTML = '';
            
            const categories = {
                'Gameplay': ['autoJump', 'autoCollectCoins'],
                'Movement': ['walkSpeed', 'sprintSpeed'],
                'Camera': ['sensitivity', 'invertY'],
                'Display': ['showDamageNumbers', 'showMinimap']
            };
            
            for (const [category, settingsList] of Object.entries(categories)) {
                const catDiv = document.createElement('div');
                catDiv.className = 'settings-category';
                
                const title = document.createElement('div');
                title.className = 'settings-category-title';
                title.textContent = category;
                catDiv.appendChild(title);
                
                settingsList.forEach(key => {
                    if (settings[key] === undefined) return;
                    
                    const row = document.createElement('div');
                    row.className = 'setting-row';
                    
                    const label = document.createElement('span');
                    label.className = 'setting-label';
                    label.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    row.appendChild(label);
                    
                    const value = settings[key];
                    
                    if (typeof value === 'boolean') {
                        const toggle = document.createElement('div');
                        toggle.className = 'toggle-switch' + (value ? ' on' : '');
                        toggle.onclick = () => {
                            settings[key] = !settings[key];
                            toggle.classList.toggle('on');
                        };
                        row.appendChild(toggle);
                    } else if (typeof value === 'number') {
                        const sliderContainer = document.createElement('div');
                        sliderContainer.className = 'slider-container';
                        
                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.className = 'slider';
                        slider.min = 0;
                        slider.max = 100;
                        slider.value = value;
                        
                        const valDisplay = document.createElement('span');
                        valDisplay.className = 'slider-value';
                        valDisplay.textContent = value;
                        
                        slider.oninput = () => {
                            settings[key] = parseInt(slider.value);
                            valDisplay.textContent = slider.value;
                        };
                        
                        sliderContainer.appendChild(slider);
                        sliderContainer.appendChild(valDisplay);
                        row.appendChild(sliderContainer);
                    }
                    
                    catDiv.appendChild(row);
                });
                
                container.appendChild(catDiv);
            }
        }
        
        let draggedSlot = null;

        function setupHotbar() {
            const el = document.getElementById('hotbar');
            el.innerHTML = '';

            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
                slot.dataset.slot = i;
                slot.onclick = () => selectSlot(i);

                const itemId = hotbar[i];
                if (itemId && itemDefs[itemId]) {
                    const item = itemDefs[itemId];
                    slot.innerHTML = `
                        <span class="slot-key">${i + 1}</span>
                        <span class="item-icon">${item.icon}</span>
                        <span class="item-name">${item.name}</span>
                        <div class="cooldown-overlay" id="cooldown${i}"></div>
                    `;
                    // Enable drag for items
                    slot.draggable = true;
                } else {
                    slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="item-icon" style="opacity:0.2">+</span>`;
                    slot.draggable = false;
                }

                // Drag events
                slot.addEventListener('dragstart', (e) => {
                    if (!hotbar[i]) { e.preventDefault(); return; }
                    draggedSlot = i;
                    slot.style.opacity = '0.5';
                    e.dataTransfer.effectAllowed = 'move';
                });

                slot.addEventListener('dragend', () => {
                    slot.style.opacity = '1';
                    draggedSlot = null;
                });

                slot.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    slot.style.background = 'rgba(255,255,0,0.3)';
                });

                slot.addEventListener('dragleave', () => {
                    slot.style.background = '';
                });

                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slot.style.background = '';
                    if (draggedSlot !== null && draggedSlot !== i) {
                        // Swap items
                        const temp = hotbar[i];
                        hotbar[i] = hotbar[draggedSlot];
                        hotbar[draggedSlot] = temp;
                        setupHotbar();
                        SFX.coinPickup(); // Play swap sound
                    }
                });

                el.appendChild(slot);
            }
            updateWeaponView();
        }
        
        function selectSlot(index) {
            selectedSlot = index;
            document.querySelectorAll('.hotbar-slot').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
            updateWeaponView();
        }
        
        function updateWeaponView() {
            // No longer needed - using 3D sword
        }
        
        function selectDevice(mode) {
            deviceMode = mode;
            document.getElementById('deviceSelect').style.display = 'none';
            document.getElementById('startSection').style.display = 'block';
        }
        
        function openShop() { document.getElementById('shopPanel').style.display = 'flex'; updateShopUI(); }
        function closeShop() { document.getElementById('shopPanel').style.display = 'none'; }
        
        function updateShopUI() {
            const el = document.getElementById('shopItems');
            el.innerHTML = '';

            shopItems.forEach(si => {
                const item = itemDefs[si.id];
                const owned = inventory.ownedItems.includes(si.id);
                const equipped = hotbar.includes(si.id);
                const canAfford = inventory.coins >= si.price;

                const div = document.createElement('div');
                div.className = 'shop-item';

                let buttonHtml = '';
                if (owned) {
                    if (equipped) {
                        buttonHtml = '<button class="shop-buy-btn" disabled style="background:#555;">Equipped</button>';
                    } else {
                        buttonHtml = `<button class="shop-buy-btn" onclick="equipItem('${si.id}')" style="background:#4a4;">Equip</button>`;
                    }
                } else {
                    buttonHtml = `<button class="shop-buy-btn" onclick="buyItem('${si.id}', ${si.price})" ${canAfford ? '' : 'disabled'}>Buy</button>`;
                }

                div.innerHTML = `
                    <span class="shop-item-icon">${item.icon}</span>
                    <div class="shop-item-info">
                        <div class="shop-item-name">${item.name}</div>
                        <div class="shop-item-desc">${item.desc}</div>
                    </div>
                    <span class="shop-item-price">${owned ? '‚úì Owned' : 'üí∞' + si.price}</span>
                    ${buttonHtml}
                `;
                el.appendChild(div);
            });

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
        }

        function equipItem(itemId) {
            // Find empty slot or replace last slot
            const emptySlot = hotbar.findIndex(s => s === null);
            if (emptySlot !== -1) {
                hotbar[emptySlot] = itemId;
            } else {
                // Replace slot 6 (last slot)
                hotbar[5] = itemId;
            }
            setupHotbar();
            updateShopUI();
        }
        
        function buyItem(itemId, price) {
            if (inventory.coins >= price && !inventory.ownedItems.includes(itemId)) {
                inventory.coins -= price;
                inventory.ownedItems.push(itemId);
                const emptySlot = hotbar.findIndex(s => s === null);
                if (emptySlot !== -1) hotbar[emptySlot] = itemId;
                updateShopUI();
                setupHotbar();
                saveCoinsToCloud(); // Save to cloud after purchase
            }
        }

        // Stripe Coin Purchase System
        const COIN_PACKS = {
            pack_500: { coins: 500, price: 99, name: '500 Coins' },
            pack_1200: { coins: 1200, price: 199, name: '1,200 Coins (+200 bonus)' },
            pack_3500: { coins: 3500, price: 499, name: '3,500 Coins (+700 bonus)' },
            pack_10000: { coins: 10000, price: 999, name: '10,000 Coins (+2,500 bonus)' }
        };

        async function buyCoins(packId) {
            const pack = COIN_PACKS[packId];
            if (!pack) return;

            try {
                // Show loading state
                const packElements = document.querySelectorAll('.coin-pack');
                packElements.forEach(el => el.style.pointerEvents = 'none');

                // Create checkout session
                const response = await fetch('/api/stripe-checkout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        packId: packId,
                        coins: pack.coins,
                        price: pack.price,
                        name: pack.name
                    })
                });

                const data = await response.json();

                if (data.url) {
                    // Redirect to Stripe Checkout
                    window.location.href = data.url;
                } else if (data.error) {
                    alert('Error: ' + data.error);
                    packElements.forEach(el => el.style.pointerEvents = 'auto');
                }
            } catch (error) {
                console.error('Checkout error:', error);
                alert('Failed to start checkout. Please try again.');
                document.querySelectorAll('.coin-pack').forEach(el => el.style.pointerEvents = 'auto');
            }
        }

        // Check for successful payment on page load
        function checkPaymentSuccess() {
            const urlParams = new URLSearchParams(window.location.search);
            const success = urlParams.get('payment_success');
            const coins = urlParams.get('coins');

            if (success === 'true' && coins) {
                const coinsToAdd = parseInt(coins);
                inventory.coins += coinsToAdd;
                saveCoinsToCloud();

                // Show success message
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#4CAF50,#45a049);color:white;padding:30px 50px;border-radius:20px;font-size:24px;z-index:10000;text-align:center;animation:fadeIn 0.5s;';
                msg.innerHTML = `<div style="font-size:48px;margin-bottom:10px;">üéâ</div>+${coinsToAdd.toLocaleString()} Coins Added!<div style="font-size:14px;margin-top:10px;opacity:0.8;">Thank you for your purchase!</div>`;
                document.body.appendChild(msg);

                setTimeout(() => msg.remove(), 4000);

                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        function openSettings() { document.getElementById('settingsPanel').style.display = 'flex'; }
        function closeSettings() { document.getElementById('settingsPanel').style.display = 'none'; }
        function quitGame() { location.reload(); }
        
        function enterFullscreen() {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        }
        
        function setupInput() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                    selectSlot(parseInt(e.code.replace('Digit', '')) - 1);
                }
                // H key - Toggle hitbox visualization
                if (e.code === 'KeyH') {
                    toggleHitboxes();
                }
                // M key - Toggle background music
                if (e.code === 'KeyM') {
                    toggleMusic();
                }
            });
            document.addEventListener('keyup', (e) => { keys[e.code] = false; });
            
            if (deviceMode === 'computer') setupComputerControls();
            else setupMobileControls();
        }
        
        function setupComputerControls() {
            const canvas = renderer.domElement;

            // Request pointer lock on canvas click
            canvas.addEventListener('click', (e) => {
                if (gameRunning && document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                }
            });

            // Use mousedown for attacks (works better with pointer lock)
            document.addEventListener('mousedown', (e) => {
                if (!gameRunning) return;
                if (document.pointerLockElement === canvas) {
                    if (e.button === 0) { // Left click = attack
                        useCurrentItem();
                    }
                }
            });

            // Handle pointer lock change
            document.addEventListener('pointerlockchange', () => {
                const clickMsg = document.getElementById('clickToPlay');
                if (document.pointerLockElement === canvas) {
                    clickMsg.style.display = 'none';
                } else if (gameRunning && deviceMode === 'computer') {
                    clickMsg.style.display = 'block';
                }
            });

            // Mouse movement with pointer lock
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas && gameRunning) {
                    const sens = settings.sensitivity / 8000;
                    playerState.rotation.y -= e.movementX * sens;
                    playerState.rotation.x -= e.movementY * sens * (settings.invertY ? -1 : 1);
                    playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                }
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function setupMobileControls() {
            document.body.classList.add('mobile-mode');
            
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            
            let moveTouchId = null;
            let lookTouchId = null;
            let moveStartX = 0, moveStartY = 0;
            let lookStartX = 0, lookStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                
                const jRect = joystickZone.getBoundingClientRect();
                const aRect = document.getElementById('attackBtn').getBoundingClientRect();
                const jRect2 = document.getElementById('jumpBtn').getBoundingClientRect();
                const dRect = document.getElementById('dashBtn').getBoundingClientRect();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const tx = t.clientX, ty = t.clientY;
                    
                    // Check buttons
                    if (tx >= aRect.left && tx <= aRect.right && ty >= aRect.top && ty <= aRect.bottom) {
                        useCurrentItem(); continue;
                    }
                    if (tx >= jRect2.left && tx <= jRect2.right && ty >= jRect2.top && ty <= jRect2.bottom) {
                        jump(); continue;
                    }
                    if (tx >= dRect.left && tx <= dRect.right && ty >= dRect.top && ty <= dRect.bottom) {
                        dash(); continue;
                    }
                    
                    // Joystick
                    if (tx >= jRect.left && tx <= jRect.right && ty >= jRect.top && ty <= jRect.bottom) {
                        if (moveTouchId === null) {
                            moveTouchId = t.identifier;
                            const bRect = joystickBase.getBoundingClientRect();
                            moveStartX = bRect.left + bRect.width / 2;
                            moveStartY = bRect.top + bRect.height / 2;
                            joystickActive = true;
                        }
                        continue;
                    }
                    
                    // Look
                    if (lookTouchId === null) {
                        lookTouchId = t.identifier;
                        lookStartX = tx;
                        lookStartY = ty;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    
                    // Joystick - FIXED DIRECTION
                    if (t.identifier === moveTouchId) {
                        const dx = t.clientX - moveStartX;
                        const dy = t.clientY - moveStartY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const maxDist = 35;
                        
                        if (dist > 0) {
                            const clampedDist = Math.min(dist, maxDist);
                            const ratio = clampedDist / maxDist;
                            
                            // X is left/right (strafe), Y is forward/back
                            // Up on screen (negative dy) = forward in game
                            joystickX = (dx / dist) * ratio;
                            joystickY = (-dy / dist) * ratio;
                            
                            const vx = (dx / dist) * clampedDist;
                            const vy = (dy / dist) * clampedDist;
                            joystickKnob.style.transform = `translate(${vx}px, ${vy}px)`;
                        } else {
                            joystickX = 0;
                            joystickY = 0;
                            joystickKnob.style.transform = 'translate(0, 0)';
                        }
                    }
                    
                    // Look
                    if (t.identifier === lookTouchId) {
                        const sens = settings.sensitivity / 1500;
                        const dx = t.clientX - lookStartX;
                        const dy = t.clientY - lookStartY;
                        
                        playerState.rotation.y -= dx * sens;
                        playerState.rotation.x -= dy * sens * (settings.invertY ? -1 : 1);
                        playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                        
                        lookStartX = t.clientX;
                        lookStartY = t.clientY;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        moveTouchId = null;
                        joystickActive = false;
                        joystickX = 0;
                        joystickY = 0;
                        joystickKnob.style.transform = 'translate(0, 0)';
                    }
                    if (t.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            }, { passive: true });
        }
        
        let minimapCtx;
        function setupMinimap() {
            const c = document.getElementById('minimapCanvas');
            c.width = 90; c.height = 90;
            minimapCtx = c.getContext('2d');
        }
        
        function updateMinimap() {
            if (!minimapCtx || !settings.showMinimap) return;
            minimapCtx.fillStyle = 'rgba(20,40,20,0.9)';
            minimapCtx.fillRect(0, 0, 90, 90);
            
            const scale = 0.25;
            const cx = 45, cy = 45;
            
            // Buildings
            minimapCtx.fillStyle = '#886644';
            buildings.forEach(b => {
                const bx = cx + (b.x - playerState.position.x) * scale;
                const by = cy + (b.z - playerState.position.z) * scale;
                minimapCtx.fillRect(bx - 3, by - 3, 6, 6);
            });
            
            // Enemies
            minimapCtx.fillStyle = '#ff4444';
            enemies.forEach(e => {
                if (!e.mesh) return;
                const ex = cx + (e.mesh.position.x - playerState.position.x) * scale;
                const ey = cy + (e.mesh.position.z - playerState.position.z) * scale;
                if (ex > 0 && ex < 90 && ey > 0 && ey < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(ex, ey, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Coins
            minimapCtx.fillStyle = 'gold';
            coins.forEach(c => {
                if (!c.mesh) return;
                const coinX = cx + (c.mesh.position.x - playerState.position.x) * scale;
                const coinY = cy + (c.mesh.position.z - playerState.position.z) * scale;
                if (coinX > 0 && coinX < 90 && coinY > 0 && coinY < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(coinX, coinY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Player
            minimapCtx.fillStyle = '#44ff44';
            minimapCtx.beginPath();
            minimapCtx.arc(cx, cy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            minimapCtx.strokeStyle = '#88ff88';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(cx, cy);
            minimapCtx.lineTo(cx - Math.sin(playerState.rotation.y) * 8, cy - Math.cos(playerState.rotation.y) * 8);
            minimapCtx.stroke();
        }
        
        function updateHUD() {
            const hp = (playerState.health / playerState.maxHealth) * 100;
            document.querySelector('#healthBar .bar-fill').style.width = hp + '%';
            document.querySelector('#healthBar .bar-text').textContent = Math.ceil(playerState.health) + '/' + playerState.maxHealth;
            
            const ep = (playerState.energy / playerState.maxEnergy) * 100;
            document.querySelector('#energyBar .bar-fill').style.width = ep + '%';
            document.querySelector('#energyBar .bar-text').textContent = Math.ceil(playerState.energy) + '/' + playerState.maxEnergy;

            // Update ability indicators
            const dashInd = document.getElementById('dashIndicator');
            const slideInd = document.getElementById('slideIndicator');

            if (dashInd) {
                dashInd.className = 'ability-icon';
                if (playerState.isDashing) {
                    dashInd.classList.add('active');
                } else if (playerState.dashCooldown > 0) {
                    dashInd.classList.add('cooldown');
                } else if (playerState.energy >= 15) {
                    dashInd.classList.add('ready');
                }
            }

            if (slideInd) {
                slideInd.className = 'ability-icon';
                if (playerState.isSliding) {
                    slideInd.classList.add('active');
                } else if (playerState.slideCooldown > 0) {
                    slideInd.classList.add('cooldown');
                } else if (playerState.energy >= 10) {
                    slideInd.classList.add('ready');
                }
            }

            // Jump indicator - shows remaining jumps
            const jumpInd = document.getElementById('jumpIndicator');
            if (jumpInd) {
                jumpInd.className = 'ability-icon';
                if (playerState.jumpsRemaining === 2) {
                    jumpInd.classList.add('ready');
                    jumpInd.textContent = '‚¨ÜÔ∏è2';
                } else if (playerState.jumpsRemaining === 1) {
                    jumpInd.classList.add('active');
                    jumpInd.textContent = '‚¨ÜÔ∏è1';
                } else {
                    jumpInd.classList.add('cooldown');
                    jumpInd.textContent = '‚¨ÜÔ∏è0';
                }
            }

            // Wall run indicator
            const wallInd = document.getElementById('wallRunIndicator');
            if (wallInd) {
                wallInd.className = 'ability-icon';
                if (playerState.isWallRunning) {
                    wallInd.classList.add('active');
                } else if (playerState.wallRunCooldown > 0) {
                    wallInd.classList.add('cooldown');
                } else if (!playerState.isGrounded) {
                    wallInd.classList.add('ready');
                }
            }

            document.getElementById('waveNum').textContent = currentWave;
            document.getElementById('score').textContent = playerState.score;
            document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
            
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById('cooldown' + i);
                if (!el) continue;
                const itemId = hotbar[i];
                if (itemId && itemCooldowns[itemId] > 0) {
                    el.style.display = 'block';
                    el.textContent = Math.ceil(itemCooldowns[itemId] / 1000);
                } else {
                    el.style.display = 'none';
                }
            }
        }
        
        function useCurrentItem() {
            const itemId = hotbar[selectedSlot];
            if (!itemId) return;
            const item = itemDefs[itemId];
            if (!item || itemCooldowns[itemId] > 0) return;
            if (item.energy && playerState.energy < item.energy) return;
            
            itemCooldowns[itemId] = item.cooldown;
            if (item.energy) playerState.energy -= item.energy;
            
            // Handle by item type for easier management
            if (item.type === 'weapon') {
                // Melee weapons with different ranges
                const ranges = { spear: 3.5, gungnir: 3.5, halberd: 3.2, bo_staff: 3.0, whip: 3.5, holy_lance: 3.2,
                                 dagger: 1.8, claws: 1.8, venom_dagger: 1.8, nunchucks: 2.0, sickle: 2.2 };
                meleeAttack(item.damage, ranges[itemId] || 2.5, itemId);
            }
            else if (item.type === 'ranged') {
                // Ranged weapons
                const colors = { bow: 0x8B4513, crossbow: 0x444444, shuriken: 0xcccccc, javelin: 0x8B4513,
                                boomerang: 0xDEB887, kunai: 0x333333, chakram: 0xffd700, blowdart: 0x228B22 };
                shootProjectile(item.damage, colors[itemId] || 0xaaaaaa);
            }
            else if (item.type === 'ability' && item.damage) {
                // Magic/projectile abilities
                const colors = {
                    fireball: 0xff4400, iceball: 0x00ccff, lightning: 0xffff00, poison: 0x00ff00,
                    laser: 0xff0000, meteor: 0xff6600, tornado: 0x888888, earthquake: 0x8B4513,
                    tsunami: 0x0066ff, vortex: 0x440088, solar: 0xffff00, lunar: 0xaaaaff,
                    arcane: 0xff00ff, nature: 0x00aa00, shadow: 0x222222, holy: 0xffffcc,
                    plasma: 0xaa00ff, gravity: 0x000000, chain_lightning: 0x00ffff, frost_nova: 0x00ffff,
                    fire_storm: 0xff2200, supernova: 0xffaa00, apocalypse: 0x330000, genesis: 0xffffff,
                    oblivion: 0x000000, grenade: 0x556b2f, dynamite: 0xff0000, molotov: 0xff4500,
                    flashbang: 0xffffff, cluster_bomb: 0xff6600, nuke: 0x00ff00,
                    summon_wolf: 0x808080, summon_dragon: 0xff0000, summon_golem: 0x8B4513,
                    summon_phoenix: 0xff6600, summon_demon: 0x8b0000
                };
                shootProjectile(item.damage, colors[itemId] || 0xffffff);
            }
            else {
                // Utility abilities
                switch (itemId) {
                    case 'shield':
                        playerState.defense += 20;
                        setTimeout(() => playerState.defense -= 20, 4000);
                        break;
                    case 'medkit':
                        playerState.health = Math.min(playerState.maxHealth, playerState.health + item.healing);
                        break;
                    case 'megaHeal':
                        playerState.health = playerState.maxHealth;
                        break;
                    case 'jumpPad':
                        playerState.velocity.y = 0.25;
                        playerState.isGrounded = false;
                        break;
                    case 'speedBoost':
                        playerState.speed *= 2;
                        playerState.sprintSpeed *= 2;
                        setTimeout(() => { playerState.speed /= 2; playerState.sprintSpeed /= 2; }, 3000);
                        break;
                    case 'rage':
                        playerState.rageModeActive = true;
                        setTimeout(() => { playerState.rageModeActive = false; }, 5000);
                        break;
                    case 'invisibility':
                        playerState.invisible = true;
                        setTimeout(() => { playerState.invisible = false; }, 5000);
                        break;
                    case 'teleport':
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        playerState.position.x += dir.x * 10;
                        playerState.position.z += dir.z * 10;
                        break;
                    case 'reflect':
                        playerState.reflecting = true;
                        setTimeout(() => { playerState.reflecting = false; }, 4000);
                        break;
                    case 'lifesteal':
                        playerState.lifestealActive = true;
                        setTimeout(() => { playerState.lifestealActive = false; }, 6000);
                        break;
                    case 'timestop':
                        playerState.timestopActive = true;
                        setTimeout(() => { playerState.timestopActive = false; }, 3000);
                        break;
                    case 'clone':
                        // Visual effect only for now
                        break;
                    case 'berserk':
                        playerState.berserkActive = true;
                        setTimeout(() => { playerState.berserkActive = false; }, 5000);
                        break;
                    case 'fortify':
                        playerState.defense += 50;
                        setTimeout(() => playerState.defense -= 50, 6000);
                        break;
                    case 'regenerate':
                        playerState.regenerating = true;
                        setTimeout(() => { playerState.regenerating = false; }, 10000);
                        break;
                    case 'energize':
                        playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 50);
                        break;
                    case 'smoke_bomb':
                        // Escape utility
                        break;
                }
            }
        }
        
        // Weapon animation types based on weapon characteristics
        const weaponAnimations = {
            // Slashing weapons - horizontal arc
            sword: 'slash', katana: 'slash', excalibur: 'slash', kusanagi: 'slash', sickle: 'slash', scythe: 'slash',
            // Stabbing weapons - forward thrust
            spear: 'thrust', dagger: 'thrust', gungnir: 'thrust', halberd: 'thrust', holy_lance: 'thrust',
            // Heavy weapons - overhead smash
            axe: 'smash', hammer: 'smash', mace: 'smash', mjolnir: 'smash', anchor: 'smash', pickaxe: 'smash',
            // Fast weapons - rapid multi-hit
            claws: 'rapid', nunchucks: 'rapid', dagger: 'rapid',
            // Spinning weapons - spin attack
            flail: 'spin', chainsaw: 'spin', bo_staff: 'spin',
            // Punching weapons - punch animation
            gauntlet: 'punch', wrench: 'punch', shovel: 'punch',
            // Whip weapons - crack animation
            whip: 'whip'
        };
        let currentWeaponAnim = 'slash';

        function meleeAttack(damage, range = 2.5, weaponId = 'sword') {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            // Set animation type based on weapon
            currentWeaponAnim = weaponAnimations[weaponId] || 'slash';

            // Start weapon swing animation
            swordSwinging = true;
            swordSwingTime = 0;
            if (swordMesh) swordMesh.visible = true;

            // Play appropriate sound based on weapon type
            if (currentWeaponAnim === 'smash') {
                SFX.swordSwing(); // Heavy sound
            } else if (currentWeaponAnim === 'rapid') {
                SFX.swordSwing(); // Quick sound
            } else {
                SFX.swordSwing();
            }

            const raycaster = new THREE.Raycaster();
            raycaster.far = range;
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            raycaster.set(camera.position, dir);

            // Create slash particle effect
            const slashPos = camera.position.clone().add(dir.clone().multiplyScalar(1));
            createSlashParticles(slashPos, dir, 0xccccff);

            const enemyMeshes = enemies.map(e => e.mesh).filter(m => m);

            // Improved hitbox detection - check all enemies in cone
            let hitEnemy = null;
            let closestDist = range;
            enemies.forEach(e => {
                if (!e.mesh || e.dying) return;
                const enemyPos = e.mesh.position.clone();
                enemyPos.y += 0.8; // Aim at center mass
                const distToEnemy = camera.position.distanceTo(enemyPos);
                if (distToEnemy < range + 0.5) {
                    // Wider cone for better hit detection
                    const toEnemy = enemyPos.clone().sub(camera.position).normalize();
                    const dot = toEnemy.dot(dir);
                    if (dot > 0.4 && distToEnemy < closestDist) { // Lowered threshold, closer enemy prioritized
                        hitEnemy = e;
                        closestDist = distToEnemy;
                    }
                }
            });

            if (hitEnemy) {
                damageEnemy(hitEnemy, damage, Math.random() < 0.15);
                SFX.swordHit(); // Play hit sound
                // Hit particles on enemy
                const hitPos = hitEnemy.mesh.position.clone();
                hitPos.y += 0.8;
                createHitParticles(hitPos, 0xff4400);
            }

            if (boss && boss.mesh) {
                const bossPos = boss.mesh.position.clone();
                bossPos.y += 1.2; // Aim at boss center
                const distToBoss = camera.position.distanceTo(bossPos);
                const bossRange = boss.type === 'dragon' ? 4.5 : 3.5; // Larger hitbox for dragon
                if (distToBoss < bossRange) {
                    const toBoss = bossPos.clone().sub(camera.position).normalize();
                    const dot = toBoss.dot(dir);
                    if (dot > 0.3) { // Wider cone for boss
                        damageBoss(damage, Math.random() < 0.15);
                        SFX.swordHit(); // Play hit sound
                        // Hit particles on boss
                        const hitPos = boss.mesh.position.clone();
                        hitPos.y += 1.5;
                        createHitParticles(hitPos, 0xff0000);
                    }
                }
            }
        }
        
        function shootProjectile(damage, color) {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            // Play fireball/magic sound
            SFX.fireball();

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            // Cast particles at player position
            const castPos = camera.position.clone().add(dir.clone().multiplyScalar(0.5));
            createMagicParticles(castPos, color, 8, 0.05);

            const geo = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color });
            const proj = new THREE.Mesh(geo, mat);
            proj.position.copy(camera.position);
            scene.add(proj);

            // Add glow effect to projectile
            const glowGeo = new THREE.SphereGeometry(0.22, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            proj.add(glow);

            projectiles.push({ mesh: proj, direction: dir.clone(), speed: 0.25, damage, life: 3000, color: color, trailTimer: 0 });
        }

        function jump() {
            // Wall jump - if wall running, jump off the wall
            if (playerState.isWallRunning) {
                playerState.isWallRunning = false;
                playerState.velocity.y = 0.12;
                // Push away from wall
                playerState.velocity.x = playerState.wallNormal.x * 0.08;
                playerState.velocity.z = playerState.wallNormal.z * 0.08;
                playerState.jumpsRemaining = 1; // Can still double jump after wall jump
                playerState.wallRunCooldown = 300;
                SFX.jump();
                createParticles(playerState.position.clone(), 0xaaaaaa, 8, 0.06, 0.1, 200);
                return;
            }

            // Double jump system
            if (playerState.jumpsRemaining > 0) {
                const isDoubleJump = !playerState.isGrounded && playerState.jumpsRemaining < playerState.maxJumps;

                playerState.velocity.y = isDoubleJump ? 0.09 : 0.1; // Slightly lower double jump
                playerState.isGrounded = false;
                playerState.jumpsRemaining--;
                SFX.jump();

                // Double jump particles
                if (isDoubleJump) {
                    const particlePos = playerState.position.clone();
                    particlePos.y -= 1.5;
                    createParticles(particlePos, 0x88ffff, 12, 0.08, 0.12, 250);
                }
            }
        }

        function dash() {
            if (playerState.energy < 10) return;
            SFX.dash(); // Play dash sound
            playerState.energy -= 10;
            
            let mx = 0, mz = 0;
            if (deviceMode === 'mobile') {
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;
                if (keys['KeyS']) mz = 1;
                if (keys['KeyA']) mx = -1;
                if (keys['KeyD']) mx = 1;
            }
            
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);
            const wx = mx * cos + mz * sin;
            const wz = mz * cos - mx * sin;

            if (wx === 0 && wz === 0) return;
            const len = Math.sqrt(wx * wx + wz * wz);
            
            const newX = playerState.position.x + (wx / len) * 2;
            const newZ = playerState.position.z + (wz / len) * 2;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            }
        }
        
        function checkCollision(x, z) {
            const r = 0.35;
            for (const col of colliders) {
                const dx = x - col.position.x;
                const dz = z - col.position.z;
                
                if (col.type === 'cylinder' || col.type === 'sphere') {
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < col.radius + r) {
                        if (settings.autoJump && col.canAutoJump && playerState.isGrounded) {
                            playerState.velocity.y = 0.08;
                            playerState.isGrounded = false;
                            return false;
                        }
                        return true;
                    }
                } else if (col.type === 'box') {
                    if (Math.abs(dx) < col.width / 2 + r && Math.abs(dz) < col.depth / 2 + r) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Enemy types with different stats and appearances - more detailed
        const enemyTypes = [
            { name: 'Grunt', bodyColor: 0x8B4513, skinColor: 0xDEB887, eyeColor: 0xff3300,
              armorColor: 0x654321, accentColor: 0xA0522D, glowColor: null,
              weapon: 'sword', weaponColor: 0xcccccc, health: 1.0, damage: 1.0, speed: 1.0,
              hasCape: false, hasAura: false, scarCount: 1, scale: 1.0, ability: null },
            { name: 'Brute', bodyColor: 0x8B0000, skinColor: 0xCD5C5C, eyeColor: 0xffff00,
              armorColor: 0x2F1010, accentColor: 0xff4444, glowColor: 0xff2200,
              weapon: 'axe', weaponColor: 0x555555, health: 1.8, damage: 1.6, speed: 0.7,
              hasCape: false, hasAura: true, scarCount: 3, scale: 1.15, ability: 'charge' },
            { name: 'Assassin', bodyColor: 0x1a0a1a, skinColor: 0x9370DB, eyeColor: 0x00ffff,
              armorColor: 0x2d1f3d, accentColor: 0x8A2BE2, glowColor: 0x00ffff,
              weapon: 'dagger', weaponColor: 0x222222, health: 0.6, damage: 1.3, speed: 1.5,
              hasCape: true, hasAura: false, scarCount: 0, scale: 0.9, ability: 'teleport' },
            { name: 'Mage', bodyColor: 0x191970, skinColor: 0xB0C4DE, eyeColor: 0xff00ff,
              armorColor: 0x0a0a40, accentColor: 0x4169E1, glowColor: 0x9400D3,
              weapon: 'staff', weaponColor: 0x9400D3, health: 0.7, damage: 1.8, speed: 0.9,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.0, ability: 'fireball' },
            { name: 'Knight', bodyColor: 0x2F4F4F, skinColor: 0xC0C0C0, eyeColor: 0xff4400,
              armorColor: 0x708090, accentColor: 0xFFD700, glowColor: null,
              weapon: 'hammer', weaponColor: 0x4a4a4a, health: 2.2, damage: 2.0, speed: 0.6,
              hasCape: true, hasAura: false, scarCount: 2, scale: 1.1, ability: 'shield' },
            // NEW ENEMY TYPES
            { name: 'Necromancer', bodyColor: 0x1a1a2e, skinColor: 0x98FB98, eyeColor: 0x00ff00,
              armorColor: 0x0d0d1a, accentColor: 0x228B22, glowColor: 0x00ff00,
              weapon: 'staff', weaponColor: 0x2F4F2F, health: 0.8, damage: 1.5, speed: 0.8,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.0, ability: 'summon' },
            { name: 'Berserker', bodyColor: 0x8B0000, skinColor: 0xFF6347, eyeColor: 0xff0000,
              armorColor: 0x800000, accentColor: 0xDC143C, glowColor: 0xff0000,
              weapon: 'axe', weaponColor: 0x8B0000, health: 1.5, damage: 2.5, speed: 1.3,
              hasCape: false, hasAura: true, scarCount: 5, scale: 1.2, ability: 'rage' },
            { name: 'Archer', bodyColor: 0x228B22, skinColor: 0xF5DEB3, eyeColor: 0x00ff88,
              armorColor: 0x2E8B57, accentColor: 0x3CB371, glowColor: null,
              weapon: 'bow', weaponColor: 0x8B4513, health: 0.5, damage: 1.4, speed: 1.1,
              hasCape: true, hasAura: false, scarCount: 0, scale: 0.95, ability: 'shoot' },
            { name: 'Paladin', bodyColor: 0xFFD700, skinColor: 0xFFE4B5, eyeColor: 0xffff00,
              armorColor: 0xDAA520, accentColor: 0xFFD700, glowColor: 0xffff00,
              weapon: 'sword', weaponColor: 0xFFD700, health: 2.5, damage: 1.8, speed: 0.5,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.15, ability: 'heal' },
            { name: 'Shadow', bodyColor: 0x0a0a0a, skinColor: 0x2F2F2F, eyeColor: 0xff00ff,
              armorColor: 0x1a1a1a, accentColor: 0x4B0082, glowColor: 0x8B008B,
              weapon: 'dagger', weaponColor: 0x2F2F2F, health: 0.4, damage: 1.6, speed: 2.0,
              hasCape: true, hasAura: true, scarCount: 0, scale: 0.85, ability: 'phase' },
            { name: 'Golem', bodyColor: 0x696969, skinColor: 0x808080, eyeColor: 0xff6600,
              armorColor: 0x4a4a4a, accentColor: 0x8B4513, glowColor: 0xff4400,
              weapon: 'hammer', weaponColor: 0x555555, health: 3.5, damage: 2.2, speed: 0.4,
              hasCape: false, hasAura: false, scarCount: 0, scale: 1.4, ability: 'stomp' },
            { name: 'Frost Mage', bodyColor: 0x4682B4, skinColor: 0xADD8E6, eyeColor: 0x00ffff,
              armorColor: 0x1E90FF, accentColor: 0x87CEEB, glowColor: 0x00ffff,
              weapon: 'staff', weaponColor: 0x00CED1, health: 0.65, damage: 1.6, speed: 0.85,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.0, ability: 'freeze' },
            { name: 'Vampire', bodyColor: 0x2F0000, skinColor: 0xFFF0F5, eyeColor: 0xff0000,
              armorColor: 0x1a0000, accentColor: 0x8B0000, glowColor: 0xff0000,
              weapon: 'dagger', weaponColor: 0x8B0000, health: 1.2, damage: 1.4, speed: 1.4,
              hasCape: true, hasAura: true, scarCount: 2, scale: 1.05, ability: 'lifesteal' }
        ];

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 18 + Math.random() * 12;
            const x = playerState.position.x + Math.cos(angle) * distance;
            const z = playerState.position.z + Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);

            // Pick random enemy type
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

            // Create enemy group for body parts
            const enemyGroup = new THREE.Group();

            // Body (torso) with armor
            const bodyGeo = new THREE.CylinderGeometry(0.28, 0.34, 0.85, 12);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: type.armorColor,
                roughness: 0.4,
                metalness: type.name === 'Knight' ? 0.7 : 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            enemyGroup.add(body);

            // Chest plate / armor detail
            const chestGeo = new THREE.BoxGeometry(0.45, 0.35, 0.2);
            const chestMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                roughness: 0.3,
                metalness: type.name === 'Knight' ? 0.8 : 0.3
            });
            const chest = new THREE.Mesh(chestGeo, chestMat);
            chest.position.set(0, 0.7, 0.12);
            chest.castShadow = true;
            enemyGroup.add(chest);

            // Belt
            const beltGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 12);
            const beltMat = new THREE.MeshStandardMaterial({ color: type.accentColor, roughness: 0.5, metalness: 0.4 });
            const belt = new THREE.Mesh(beltGeo, beltMat);
            belt.position.y = 0.25;
            enemyGroup.add(belt);

            // Belt buckle
            const buckleMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.95, roughness: 0.2 });
            const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.05), buckleMat);
            buckle.position.set(0, 0.25, 0.36);
            enemyGroup.add(buckle);

            // Head with better detail
            const headGeo = new THREE.SphereGeometry(0.24, 16, 14);
            const headMat = new THREE.MeshStandardMaterial({
                color: type.skinColor,
                roughness: 0.7,
                metalness: 0.1
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.18;
            head.castShadow = true;
            enemyGroup.add(head);

            // Type-specific headgear
            if (type.name === 'Knight') {
                // Helmet
                const helmetGeo = new THREE.SphereGeometry(0.27, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.6);
                const helmetMat = new THREE.MeshStandardMaterial({ color: type.armorColor, metalness: 0.8, roughness: 0.3 });
                const helmet = new THREE.Mesh(helmetGeo, helmetMat);
                helmet.position.y = 1.25;
                enemyGroup.add(helmet);
                // Helmet visor
                const visorGeo = new THREE.BoxGeometry(0.3, 0.08, 0.15);
                const visor = new THREE.Mesh(visorGeo, new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 }));
                visor.position.set(0, 1.18, 0.18);
                enemyGroup.add(visor);
            } else if (type.name === 'Mage') {
                // Wizard hood
                const hoodGeo = new THREE.ConeGeometry(0.3, 0.4, 8);
                const hoodMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.8 });
                const hood = new THREE.Mesh(hoodGeo, hoodMat);
                hood.position.y = 1.45;
                enemyGroup.add(hood);
            } else if (type.name === 'Assassin') {
                // Hood/mask
                const maskGeo = new THREE.SphereGeometry(0.26, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.7);
                const maskMat = new THREE.MeshStandardMaterial({ color: 0x1a0a1a, roughness: 0.9 });
                const mask = new THREE.Mesh(maskGeo, maskMat);
                mask.position.y = 1.22;
                enemyGroup.add(mask);
            } else if (type.name === 'Brute') {
                // Horns
                const hornGeo = new THREE.ConeGeometry(0.06, 0.2, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-0.15, 1.35, 0);
                leftHorn.rotation.z = 0.4;
                enemyGroup.add(leftHorn);
                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(0.15, 1.35, 0);
                rightHorn.rotation.z = -0.4;
                enemyGroup.add(rightHorn);
            }

            // Eyes with glow effect
            const eyeGeo = new THREE.SphereGeometry(0.055, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: type.eyeColor,
                emissive: type.eyeColor,
                emissiveIntensity: 0.9
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.09, 1.2, 0.19);
            enemyGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.09, 1.2, 0.19);
            enemyGroup.add(rightEye);

            // Eye pupils
            const pupilGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.09, 1.2, 0.24);
            enemyGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.09, 1.2, 0.24);
            enemyGroup.add(rightPupil);

            // Mouth with teeth
            const mouthGeo = new THREE.BoxGeometry(0.14, 0.05, 0.06);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x220000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 1.06, 0.19);
            enemyGroup.add(mouth);

            // Teeth
            for (let i = -2; i <= 2; i++) {
                const toothGeo = new THREE.BoxGeometry(0.02, 0.03, 0.02);
                const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffee });
                const tooth = new THREE.Mesh(toothGeo, toothMat);
                tooth.position.set(i * 0.025, 1.045, 0.22);
                enemyGroup.add(tooth);
            }

            // Shoulder pads
            const shoulderGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const shoulderMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                metalness: type.name === 'Knight' ? 0.8 : 0.3,
                roughness: 0.4
            });
            const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            leftShoulder.position.set(-0.42, 0.95, 0);
            leftShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            rightShoulder.position.set(0.42, 0.95, 0);
            rightShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(rightShoulder);

            // Arms with better detail
            const upperArmGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.3, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: type.skinColor, roughness: 0.7 });

            const leftArm = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            leftUpperArm.position.y = -0.15;
            leftArm.add(leftUpperArm);
            // Forearm with armor
            const forearmGeo = new THREE.CylinderGeometry(0.055, 0.07, 0.28, 8);
            const forearmMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.5, metalness: 0.3 });
            const leftForearm = new THREE.Mesh(forearmGeo, forearmMat);
            leftForearm.position.y = -0.38;
            leftArm.add(leftForearm);
            // Hand
            const handGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, armMat);
            leftHand.position.y = -0.52;
            leftArm.add(leftHand);
            leftArm.position.set(-0.42, 0.85, 0);
            leftArm.rotation.z = 0.2;
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            rightUpperArm.position.y = -0.15;
            rightArm.add(rightUpperArm);
            const rightForearm = new THREE.Mesh(forearmGeo, forearmMat);
            rightForearm.position.y = -0.38;
            rightArm.add(rightForearm);
            const rightHand = new THREE.Mesh(handGeo, armMat);
            rightHand.position.y = -0.52;
            rightArm.add(rightHand);
            rightArm.position.set(0.42, 0.85, 0);
            rightArm.rotation.z = -0.2;
            enemyGroup.add(rightArm);

            // Add weapon to right hand
            const weaponGroup = new THREE.Group();
            const weaponMat = new THREE.MeshStandardMaterial({ color: type.weaponColor, metalness: 0.9, roughness: 0.2 });

            if (type.weapon === 'sword') {
                // Detailed sword
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.55, 0.02), weaponMat);
                blade.position.y = -0.32;
                weaponGroup.add(blade);
                // Sword edge highlight
                const edgeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1, roughness: 0.1 });
                const edge = new THREE.Mesh(new THREE.BoxGeometry(0.052, 0.55, 0.005), edgeMat);
                edge.position.set(0, -0.32, 0.01);
                weaponGroup.add(edge);
                // Guard
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.04),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                guard.position.y = -0.02;
                weaponGroup.add(guard);
                // Handle
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.14, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 }));
                handle.position.y = 0.05;
                weaponGroup.add(handle);
                // Pommel
                const pommel = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                pommel.position.y = 0.14;
                weaponGroup.add(pommel);
            } else if (type.weapon === 'axe') {
                // Detailed axe
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.035, 0.7, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }));
                handle.position.y = -0.4;
                weaponGroup.add(handle);
                // Axe head - curved
                const axeHeadShape = new THREE.Shape();
                axeHeadShape.moveTo(0, 0);
                axeHeadShape.quadraticCurveTo(0.2, 0.1, 0.18, 0.2);
                axeHeadShape.lineTo(0.05, 0.2);
                axeHeadShape.lineTo(0.05, -0.2);
                axeHeadShape.lineTo(0.18, -0.2);
                axeHeadShape.quadraticCurveTo(0.2, -0.1, 0, 0);
                const axeHeadGeo = new THREE.ExtrudeGeometry(axeHeadShape, { depth: 0.03, bevelEnabled: false });
                const axeHead = new THREE.Mesh(axeHeadGeo, weaponMat);
                axeHead.position.set(-0.02, -0.65, -0.015);
                axeHead.rotation.z = Math.PI;
                weaponGroup.add(axeHead);
            } else if (type.weapon === 'dagger') {
                // Sleek dagger
                const blade = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.3, 4), weaponMat);
                blade.position.y = -0.2;
                blade.rotation.z = Math.PI;
                weaponGroup.add(blade);
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.03),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 }));
                guard.position.y = -0.03;
                weaponGroup.add(guard);
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.022, 0.1, 6),
                    new THREE.MeshStandardMaterial({ color: 0x1a0a1a }));
                handle.position.y = 0.03;
                weaponGroup.add(handle);
            } else if (type.weapon === 'staff') {
                // Magical staff
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.035, 1.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                staff.position.y = -0.6;
                weaponGroup.add(staff);
                // Staff rings
                for (let i = 0; i < 3; i++) {
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.008, 8, 16),
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.9 }));
                    ring.position.y = -0.2 - i * 0.25;
                    ring.rotation.x = Math.PI / 2;
                    weaponGroup.add(ring);
                }
                // Crystal orb
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16),
                    new THREE.MeshStandardMaterial({
                        color: type.weaponColor,
                        emissive: type.weaponColor,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.9
                    }));
                orb.position.y = -1.15;
                weaponGroup.add(orb);
                // Orb glow
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.13, 12, 12),
                    new THREE.MeshBasicMaterial({
                        color: type.weaponColor,
                        transparent: true,
                        opacity: 0.3
                    }));
                glow.position.y = -1.15;
                weaponGroup.add(glow);
            } else if (type.weapon === 'hammer') {
                // War hammer
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.04, 0.6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                handle.position.y = -0.35;
                weaponGroup.add(handle);
                // Leather grip
                const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.042, 0.042, 0.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 }));
                grip.position.y = -0.1;
                weaponGroup.add(grip);
                // Hammer head
                const hammerHead = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.15, 0.18), weaponMat);
                hammerHead.position.y = -0.65;
                weaponGroup.add(hammerHead);
                // Metal bands
                const bandMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9 });
                const band1 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band1.position.y = -0.58;
                weaponGroup.add(band1);
                const band2 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band2.position.y = -0.72;
                weaponGroup.add(band2);
            }

            weaponGroup.position.set(0.42, 0.32, 0.18);
            weaponGroup.rotation.x = -0.6;
            enemyGroup.add(weaponGroup);

            // Legs with boots
            const thighGeo = new THREE.CylinderGeometry(0.09, 0.1, 0.3, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.6 });
            const bootMat = new THREE.MeshStandardMaterial({ color: type.bodyColor, roughness: 0.5, metalness: 0.2 });

            const leftLeg = new THREE.Group();
            const leftThigh = new THREE.Mesh(thighGeo, legMat);
            leftThigh.position.y = -0.15;
            leftLeg.add(leftThigh);
            const leftShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            leftShin.position.y = -0.38;
            leftLeg.add(leftShin);
            const leftBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            leftBoot.position.set(0, -0.52, 0.03);
            leftLeg.add(leftBoot);
            leftLeg.position.set(-0.14, 0.22, 0);
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Group();
            const rightThigh = new THREE.Mesh(thighGeo, legMat);
            rightThigh.position.y = -0.15;
            rightLeg.add(rightThigh);
            const rightShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            rightShin.position.y = -0.38;
            rightLeg.add(rightShin);
            const rightBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            rightBoot.position.set(0, -0.52, 0.03);
            rightLeg.add(rightBoot);
            rightLeg.position.set(0.14, 0.22, 0);
            enemyGroup.add(rightLeg);

            // Add cape for certain enemy types
            if (type.hasCape) {
                const capeGroup = new THREE.Group();
                // Cape main body - flowing cloth
                const capeGeo = new THREE.PlaneGeometry(0.7, 0.9, 4, 6);
                const capeMat = new THREE.MeshStandardMaterial({
                    color: type.name === 'Knight' ? 0x8B0000 : type.armorColor,
                    roughness: 0.9,
                    side: THREE.DoubleSide
                });
                const cape = new THREE.Mesh(capeGeo, capeMat);
                cape.position.set(0, 0.5, -0.35);
                cape.rotation.x = 0.2;
                capeGroup.add(cape);
                // Cape collar
                const collarGeo = new THREE.TorusGeometry(0.32, 0.04, 8, 16, Math.PI);
                const collarMat = new THREE.MeshStandardMaterial({ color: type.accentColor, metalness: 0.6 });
                const collar = new THREE.Mesh(collarGeo, collarMat);
                collar.position.set(0, 1.0, -0.15);
                collar.rotation.x = Math.PI / 2;
                collar.rotation.z = Math.PI;
                capeGroup.add(collar);
                enemyGroup.add(capeGroup);
            }

            // Add glowing aura for certain enemy types
            if (type.hasAura && type.glowColor) {
                const auraGeo = new THREE.SphereGeometry(0.8, 12, 12);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.15
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.position.y = 0.7;
                enemyGroup.add(aura);
                // Inner aura glow
                const innerAuraGeo = new THREE.SphereGeometry(0.5, 10, 10);
                const innerAuraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.25
                });
                const innerAura = new THREE.Mesh(innerAuraGeo, innerAuraMat);
                innerAura.position.y = 0.7;
                enemyGroup.add(innerAura);
            }

            // Add battle scars/markings
            for (let s = 0; s < type.scarCount; s++) {
                const scarGeo = new THREE.BoxGeometry(0.02, 0.12 + Math.random() * 0.08, 0.01);
                const scarMat = new THREE.MeshStandardMaterial({ color: 0x330000 });
                const scar = new THREE.Mesh(scarGeo, scarMat);
                // Random position on face/body
                if (s === 0) {
                    scar.position.set(-0.05 + Math.random() * 0.1, 1.15, 0.23);
                    scar.rotation.z = -0.3 + Math.random() * 0.6;
                } else {
                    scar.position.set((Math.random() - 0.5) * 0.3, 0.5 + Math.random() * 0.4, 0.25);
                    scar.rotation.z = -0.5 + Math.random();
                }
                enemyGroup.add(scar);
            }

            // Add armor rivets/details for Knight
            if (type.name === 'Knight') {
                const rivetMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
                for (let r = 0; r < 6; r++) {
                    const rivet = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), rivetMat);
                    rivet.position.set(
                        -0.18 + (r % 3) * 0.18,
                        0.55 + Math.floor(r / 3) * 0.2,
                        0.22
                    );
                    enemyGroup.add(rivet);
                }
            }

            // Add magical runes for Mage
            if (type.name === 'Mage') {
                const runeMat = new THREE.MeshBasicMaterial({
                    color: type.weaponColor,
                    transparent: true,
                    opacity: 0.8
                });
                // Floating rune circles
                for (let r = 0; r < 3; r++) {
                    const runeRing = new THREE.Mesh(new THREE.TorusGeometry(0.08 + r * 0.03, 0.008, 8, 16), runeMat);
                    runeRing.position.set((r - 1) * 0.25, 0.6 + Math.sin(r) * 0.1, 0.35);
                    runeRing.rotation.x = Math.PI / 2 + Math.random() * 0.3;
                    enemyGroup.add(runeRing);
                }
            }

            // Add spikes for Brute
            if (type.name === 'Brute') {
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
                // Shoulder spikes
                for (let sp = 0; sp < 4; sp++) {
                    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 6), spikeMat);
                    const side = sp < 2 ? -1 : 1;
                    spike.position.set(side * 0.48, 0.95 + (sp % 2) * 0.08, (sp % 2) * 0.05);
                    spike.rotation.z = side * 0.8;
                    enemyGroup.add(spike);
                }
                // Back spikes
                for (let bs = 0; bs < 3; bs++) {
                    const backSpike = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.15, 6), spikeMat);
                    backSpike.position.set((bs - 1) * 0.15, 0.8 + bs * 0.05, -0.3);
                    backSpike.rotation.x = 0.5;
                    enemyGroup.add(backSpike);
                }
            }

            // Add smoke/shadow effect for Assassin
            if (type.name === 'Assassin') {
                const smokeMat = new THREE.MeshBasicMaterial({
                    color: 0x1a0a2a,
                    transparent: true,
                    opacity: 0.3
                });
                for (let sm = 0; sm < 5; sm++) {
                    const smoke = new THREE.Mesh(new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8), smokeMat);
                    smoke.position.set(
                        (Math.random() - 0.5) * 0.6,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.6
                    );
                    enemyGroup.add(smoke);
                }
            }

            // Apply type-specific scale
            enemyGroup.scale.setScalar(type.scale);

            // Position enemy on terrain with proper ground offset (feet at ground level)
            // Boot bottom is at -0.35 relative to group, so offset must be > 0.35
            const groundOffset = 0.4 + (0.25 * type.scale);
            enemyGroup.position.set(x, terrainY + groundOffset, z);
            scene.add(enemyGroup);

            // Create health bar above enemy head
            const healthBarGroup = new THREE.Group();

            // Background bar (dark)
            const bgGeo = new THREE.PlaneGeometry(0.8, 0.1);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
            const bgBar = new THREE.Mesh(bgGeo, bgMat);
            healthBarGroup.add(bgBar);

            // Health fill bar (red/green gradient based on health)
            const fillGeo = new THREE.PlaneGeometry(0.76, 0.06);
            const fillMat = new THREE.MeshBasicMaterial({ color: 0x44ff44, side: THREE.DoubleSide });
            const fillBar = new THREE.Mesh(fillGeo, fillMat);
            fillBar.position.z = 0.01;
            healthBarGroup.add(fillBar);

            // Border
            const borderGeo = new THREE.PlaneGeometry(0.84, 0.14);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.01;
            healthBarGroup.add(border);

            healthBarGroup.position.y = 2.2 * type.scale;
            enemyGroup.add(healthBarGroup);

            const baseHealth = 30 * (1 + currentWave * 0.08);
            const baseDamage = 10 + currentWave * 1.5;
            const baseSpeed = 0.004 + currentWave * 0.0003;

            enemies.push({
                mesh: enemyGroup,
                type: type.name,
                health: baseHealth * type.health,
                maxHealth: baseHealth * type.health,
                damage: baseDamage * type.damage,
                speed: baseSpeed * type.speed,
                attackCooldown: 0,
                radius: 0.5,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: Math.random() * Math.PI * 2,
                healthBar: healthBarGroup,
                healthBarFill: fillBar,
                stuckTime: 0,
                lastPos: new THREE.Vector3(x, 0, z)
            });
        }
        
        // Spawn the appropriate boss based on wave
        function spawnBoss() {
            if (currentWave % 10 === 0) {
                spawnDragonBoss();
            } else {
                spawnDemonBoss();
            }
        }

        // Dragon Boss - appears every 10 waves
        function spawnDragonBoss() {
            const angle = Math.random() * Math.PI * 2;
            const x = playerState.position.x + Math.cos(angle) * 35;
            const z = playerState.position.z + Math.sin(angle) * 35;
            const terrainY = getTerrainHeight(x, z);

            const bossGroup = new THREE.Group();

            // Dragon Body (elongated)
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.8, 3.5, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2d1b4e, emissive: 0x1a0033, emissiveIntensity: 0.3, roughness: 0.4, metalness: 0.3 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            body.position.set(0, 2, 0);
            body.castShadow = true;
            bossGroup.add(body);

            // Dragon Head
            const headGeo = new THREE.ConeGeometry(0.5, 1.2, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x3d2b5e, roughness: 0.5, metalness: 0.2 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.rotation.x = -Math.PI / 2;
            head.position.set(0, 2.2, 2.2);
            head.castShadow = true;
            bossGroup.add(head);

            // Dragon Eyes (glowing purple)
            const eyeGeo = new THREE.SphereGeometry(0.12, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 2.5 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.25, 2.4, 2.5);
            bossGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.25, 2.4, 2.5);
            bossGroup.add(rightEye);

            // Dragon Wings (left)
            const wingGeo = new THREE.PlaneGeometry(3, 2);
            const wingMat = new THREE.MeshStandardMaterial({ color: 0x4a2d6e, emissive: 0x220044, emissiveIntensity: 0.2, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.set(-2, 2.5, 0);
            leftWing.rotation.y = -0.3;
            leftWing.rotation.z = 0.5;
            leftWing.castShadow = true;
            bossGroup.add(leftWing);

            // Dragon Wings (right)
            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.set(2, 2.5, 0);
            rightWing.rotation.y = 0.3;
            rightWing.rotation.z = -0.5;
            rightWing.castShadow = true;
            bossGroup.add(rightWing);

            // Dragon Tail
            const tailGeo = new THREE.ConeGeometry(0.3, 2.5, 8);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            tail.rotation.x = Math.PI / 2;
            tail.position.set(0, 1.8, -2.5);
            tail.castShadow = true;
            bossGroup.add(tail);

            // Tail Spikes
            for (let i = 0; i < 4; i++) {
                const spikeGeo = new THREE.ConeGeometry(0.08, 0.4, 6);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x1a0033, metalness: 0.5 });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                spike.position.set(0, 2.2, -1 - i * 0.5);
                spike.rotation.x = -0.3;
                bossGroup.add(spike);
            }

            // Dragon Legs
            const legGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 8);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2d1b4e, roughness: 0.6 });

            const frontLeftLeg = new THREE.Mesh(legGeo, legMat);
            frontLeftLeg.position.set(-0.5, 0.75, 1);
            bossGroup.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeo, legMat);
            frontRightLeg.position.set(0.5, 0.75, 1);
            bossGroup.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeo, legMat);
            backLeftLeg.position.set(-0.5, 0.75, -1);
            bossGroup.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeo, legMat);
            backRightLeg.position.set(0.5, 0.75, -1);
            bossGroup.add(backRightLeg);

            // Fire breath particles (decorative)
            const fireGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const fireMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff2200, emissiveIntensity: 1.5, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 5; i++) {
                const fireBall = new THREE.Mesh(fireGeo, fireMat);
                fireBall.position.set((Math.random() - 0.5) * 0.3, 2.1 + Math.random() * 0.2, 2.8 + i * 0.2);
                fireBall.scale.setScalar(0.5 + Math.random() * 0.5);
                bossGroup.add(fireBall);
            }

            bossGroup.position.set(x, terrainY, z);
            bossGroup.scale.setScalar(1.3); // Dragon is bigger

            // Add BOSS label above head
            const bossLabel = createTextSprite('BOSS', 72, '#ff0000', null);
            bossLabel.position.y = 4.5;
            bossGroup.add(bossLabel);

            scene.add(bossGroup);

            boss = {
                mesh: bossGroup,
                health: 400 + currentWave * 40,
                maxHealth: 400 + currentWave * 40,
                damage: 35 + currentWave * 5,
                speed: 0.005,
                attackCooldown: 0,
                leftWing: leftWing,
                rightWing: rightWing,
                animTime: 0,
                type: 'dragon',
                bossLabel: bossLabel
            };

            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').textContent = 'üêâ DRAGON LORD - Wave ' + currentWave;
            document.getElementById('bossName').style.color = '#ff00ff';
            announceWave('üêâ DRAGON LORD');
            SFX.dragonRoar(); // Play dragon roar
        }

        // Demon Boss - original boss, appears every 5 waves (except multiples of 10)
        function spawnDemonBoss() {
            const angle = Math.random() * Math.PI * 2;
            const x = playerState.position.x + Math.cos(angle) * 28;
            const z = playerState.position.z + Math.sin(angle) * 28;
            const terrainY = getTerrainHeight(x, z);

            // Create boss group
            const bossGroup = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.7, 0.9, 1.8, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x440000, emissive: 0x220000, emissiveIntensity: 0.2, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.2;
            body.castShadow = true;
            bossGroup.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 14, 12);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x660000, roughness: 0.5 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.castShadow = true;
            bossGroup.add(head);
            
            // Glowing eyes
            const eyeGeo = new THREE.SphereGeometry(0.1, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.18, 2.5, 0.4);
            bossGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.18, 2.5, 0.4);
            bossGroup.add(rightEye);
            
            // Mouth/teeth
            const mouthGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 2.25, 0.45);
            bossGroup.add(mouth);
            
            // Horns
            const hornGeo = new THREE.ConeGeometry(0.1, 0.5, 8);
            const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 });
            
            const leftHorn = new THREE.Mesh(hornGeo, hornMat);
            leftHorn.position.set(-0.35, 2.8, 0);
            leftHorn.rotation.z = 0.4;
            bossGroup.add(leftHorn);
            
            const rightHorn = new THREE.Mesh(hornGeo, hornMat);
            rightHorn.position.set(0.35, 2.8, 0);
            rightHorn.rotation.z = -0.4;
            bossGroup.add(rightHorn);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.2, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.6 });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.95, 1.4, 0);
            leftArm.rotation.z = 0.4;
            bossGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.95, 1.4, 0);
            rightArm.rotation.z = -0.4;
            bossGroup.add(rightArm);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x330000, roughness: 0.7 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.3, 0.45, 0);
            bossGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.3, 0.45, 0);
            bossGroup.add(rightLeg);
            
            bossGroup.position.set(x, terrainY, z);

            // Add BOSS label above head
            const bossLabel = createTextSprite('BOSS', 72, '#ff0000', null);
            bossLabel.position.y = 3.5;
            bossGroup.add(bossLabel);

            scene.add(bossGroup);

            boss = {
                mesh: bossGroup,
                health: 180 + currentWave * 25,
                maxHealth: 180 + currentWave * 25,
                damage: 20 + currentWave * 3,
                speed: 0.004,
                attackCooldown: 0,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: 0,
                type: 'demon',
                bossLabel: bossLabel
            };

            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').textContent = 'üëπ DEMON LORD - Wave ' + currentWave;
            document.getElementById('bossName').style.color = '#ff4444';
            announceWave('üëπ DEMON LORD');
            SFX.bossRoar(); // Play demon roar
        }
        
        function damageEnemy(enemy, damage, isCrit) {
            if (enemy.dying) return; // Don't damage dying enemies
            enemy.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(enemy.mesh.position, damage, isCrit);

            // Play enemy hit sound
            SFX.enemyHit();

            // Flash all meshes in the enemy group white
            enemy.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.emissive = new THREE.Color(0xffffff);
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (child.material) child.material.emissiveIntensity = 0;
                    }, 80);
                }
            });

            if (enemy.health <= 0) killEnemy(enemy);
        }

        function damageBoss(damage, isCrit) {
            boss.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(boss.mesh.position, damage, isCrit);
            document.getElementById('bossFill').style.width = (boss.health / boss.maxHealth * 100) + '%';
            SFX.enemyHit(); // Play hit sound
            if (boss.health <= 0) killBoss();
        }
        
        function showDamageNumber(pos, damage, isCrit) {
            const sp = pos.clone().project(camera);
            const x = (sp.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-sp.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'damage-number';
            div.textContent = Math.round(damage);
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.color = isCrit ? '#ffff00' : '#ffffff';
            div.style.fontSize = isCrit ? '20px' : '14px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }
        
        function killEnemy(enemy) {
            if (enemy.dying) return;
            enemy.dying = true;

            // Play death sound
            SFX.enemyDeath();

            // Death particles
            const deathPos = enemy.mesh.position.clone();
            deathPos.y += 0.7;
            createDeathParticles(deathPos, 0x880000);

            spawnCoin(enemy.mesh.position.clone());

            playerState.score += 100;
            playerState.kills++;
            playerState.health = Math.min(playerState.maxHealth, playerState.health + 2);
            playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 5);
            updateHUD();

            // Death animation: fall over and fade out
            const startY = enemy.mesh.position.y;
            const startRotation = enemy.mesh.rotation.x;
            let deathTime = 0;
            const deathDuration = 600;

            function animateDeath() {
                deathTime += 16;
                const progress = Math.min(deathTime / deathDuration, 1);

                // Fall backwards
                enemy.mesh.rotation.x = startRotation + progress * (Math.PI / 2);
                enemy.mesh.position.y = startY - progress * 0.5;

                // Fade out all materials
                enemy.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = 1 - progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(animateDeath);
                } else {
                    // Remove enemy after animation
                    scene.remove(enemy.mesh);
                    const idx = enemies.indexOf(enemy);
                    if (idx > -1) enemies.splice(idx, 1);
                    checkWaveComplete();
                }
            }

            animateDeath();
        }
        
        function killBoss() {
            // Play massive explosion sound
            SFX.explosion();
            setTimeout(() => SFX.explosion(), 150);
            setTimeout(() => SFX.explosion(), 300);

            // Massive death explosion for boss
            const bossPos = boss.mesh.position.clone();
            bossPos.y += 1.2;
            createExplosionParticles(bossPos, 0xff0000, 0xff6600);
            createDeathParticles(bossPos, 0x660000);
            createMagicParticles(bossPos, 0xffff00, 20, 0.1);
            // Extra explosions around boss
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const offsetPos = bossPos.clone();
                    offsetPos.x += (Math.random() - 0.5) * 2;
                    offsetPos.y += (Math.random() - 0.5) * 1;
                    offsetPos.z += (Math.random() - 0.5) * 2;
                    createExplosionParticles(offsetPos, 0xff4400, 0xffaa00);
                }, i * 150);
            }

            for (let i = 0; i < 6; i++) {
                const pos = boss.mesh.position.clone();
                pos.x += (Math.random() - 0.5) * 3;
                pos.z += (Math.random() - 0.5) * 3;
                spawnCoin(pos);
            }

            scene.remove(boss.mesh);
            playerState.score += 1000;
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;

            boss = null;
            document.getElementById('bossHealth').style.display = 'none';
            announceWave('BOSS DEFEATED!');
            updateHUD();

            setTimeout(() => { currentWave++; startWave(); }, 3000);
        }
        
        function spawnCoin(position) {
            const geo = new THREE.CylinderGeometry(0.2, 0.2, 0.06, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFD93D, metalness: 0.9, roughness: 0.1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            const terrainY = getTerrainHeight(position.x, position.z);
            mesh.position.y = terrainY + 0.5;
            mesh.rotation.x = Math.PI / 2;
            scene.add(mesh);
            
            coins.push({ mesh, value: 5 + Math.floor(currentWave / 2), bobOffset: Math.random() * Math.PI * 2, baseY: terrainY + 0.5 });
        }
        
        function damagePlayer(damage) {
            // I-frames during dash - player is invincible
            if (playerState.isDashing) {
                // Show dodge effect
                createParticles(playerState.position.clone(), 0xffffff, 5, 0.05, 0.08, 150);
                return; // No damage taken
            }

            const finalDamage = Math.max(1, damage - playerState.defense);
            playerState.health -= finalDamage;

            // Play player hit sound
            SFX.playerHit();

            const v = document.createElement('div');
            v.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,transparent 40%,rgba(255,0,0,0.25) 100%);pointer-events:none;z-index:150;';
            document.body.appendChild(v);
            setTimeout(() => v.remove(), 150);

            if (playerState.health <= 0) {
                SFX.playerDeath();
                gameOver();
            }
            updateHUD();
        }
        
        function announceWave(text) {
            const el = document.getElementById('waveAnnounce');
            el.textContent = text;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 2000);
        }
        
        function startWave() {
            waveInProgress = true;
            SFX.waveStart(); // Play wave start sound
            announceWave('WAVE ' + currentWave);
            
            const count = 3 + currentWave * 2;
            let spawned = 0;
            const interval = setInterval(() => {
                if (spawned >= count) {
                    clearInterval(interval);
                    if (currentWave % 5 === 0) setTimeout(spawnBoss, 2000);
                    return;
                }
                spawnEnemy();
                spawned++;
            }, 800);
        }
        
        function checkWaveComplete() {
            if (enemies.length === 0 && !boss && waveInProgress) {
                waveInProgress = false;
                playerState.score += currentWave * 50;
                playerState.health = Math.min(playerState.maxHealth, playerState.health + 10);
                announceWave('WAVE COMPLETE!');
                setTimeout(() => { currentWave++; startWave(); }, 3000);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            stopBackgroundMusic(); // Stop music on game over
            // Clear hitbox visualization
            showHitboxes = false;
            hitboxMeshes.forEach(m => scene.remove(m));
            hitboxMeshes = [];

            document.getElementById('finalWave').textContent = currentWave;
            document.getElementById('finalScore').textContent = playerState.score;
            document.getElementById('finalCoins').textContent = inventory.coins;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('clickToPlay').style.display = 'none';
            // Release pointer lock so user can click buttons
            if (document.exitPointerLock) document.exitPointerLock();
            saveCoinsToCloud(); // Save coins when game ends
        }
        
        // Get terrain height at any position
        function updatePlayer(dt) {
            // Update cooldowns
            if (playerState.dashCooldown > 0) playerState.dashCooldown -= dt;
            if (playerState.slideCooldown > 0) playerState.slideCooldown -= dt;
            if (playerState.slowTime > 0) {
                playerState.slowTime -= dt;
                if (playerState.slowTime <= 0) playerState.slowed = false;
            }

            // VERY SLOW speeds
            const baseSpeed = 0.015 + (settings.walkSpeed - 50) * 0.0003;
            const baseSprint = 0.025 + (settings.sprintSpeed - 50) * 0.0005;

            // Apply slow effect
            const slowMult = playerState.slowed ? 0.5 : 1.0;

            const isSprint = keys['ShiftLeft'];
            let speed = (isSprint ? baseSprint : baseSpeed) * slowMult;

            let mx = 0, mz = 0;

            if (deviceMode === 'mobile') {
                // joystickX = strafe (left/right), joystickY = forward/back
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;  // Forward
                if (keys['KeyS']) mz = 1; // Backward
                if (keys['KeyA']) mx = -1; // Strafe left
                if (keys['KeyD']) mx = 1;  // Strafe right
                if (mx !== 0 && mz !== 0) {
                    const len = Math.sqrt(mx * mx + mz * mz);
                    mx /= len;
                    mz /= len;
                }
            }

            // Calculate world movement based on camera direction
            // Forward (positive mz) moves in camera's look direction
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);

            // Standard FPS movement relative to camera direction
            // W = forward (where you're looking), S = backward, A = strafe left, D = strafe right
            let worldMoveX = mx * cos + mz * sin;
            let worldMoveZ = mz * cos - mx * sin;

            // === DASH ABILITY (Q, E, or Shift+W) ===
            const dashKeyPressed = keys['KeyQ'] || keys['KeyE'] || (keys['ShiftLeft'] && keys['KeyW'] && !isSprint);
            if (dashKeyPressed && playerState.dashCooldown <= 0 && !playerState.isDashing && !playerState.isSliding && playerState.energy >= 15) {
                keys['KeyQ'] = false; keys['KeyE'] = false; // Consume key press
                playerState.isDashing = true;
                playerState.dashTime = 150; // 150ms dash duration
                playerState.dashCooldown = 800; // 800ms cooldown
                playerState.energy -= 15;

                // Dash direction (where player is moving, or forward if standing still)
                if (Math.abs(worldMoveX) > 0.01 || Math.abs(worldMoveZ) > 0.01) {
                    playerState.dashDir.set(worldMoveX, 0, worldMoveZ).normalize();
                } else {
                    // Dash forward if not moving
                    playerState.dashDir.set(sin, 0, cos);
                }

                SFX.swordSwing(); // Whoosh sound
                createParticles(playerState.position.clone(), 0x88ccff, 15, 0.08, 0.1, 200);
            }

            // === SLIDE ABILITY (C, X, or Ctrl) ===
            const slideKeyPressed = keys['KeyC'] || keys['KeyX'] || keys['ControlLeft'] || keys['ControlRight'];
            if (slideKeyPressed && playerState.slideCooldown <= 0 && !playerState.isSliding && !playerState.isDashing && playerState.isGrounded && playerState.energy >= 10) {
                keys['KeyC'] = false; keys['KeyX'] = false; // Consume key press
                playerState.isSliding = true;
                playerState.slideTime = 400; // 400ms slide duration
                playerState.slideCooldown = 1000; // 1s cooldown
                playerState.energy -= 10;

                // Slide direction (where player is moving, or forward if standing still)
                if (Math.abs(worldMoveX) > 0.01 || Math.abs(worldMoveZ) > 0.01) {
                    playerState.slideDir.set(worldMoveX, 0, worldMoveZ).normalize();
                } else {
                    // Slide forward if not moving
                    playerState.slideDir.set(sin, 0, cos);
                }

                SFX.swordHit(); // Slide sound
                createParticles(playerState.position.clone().add(new THREE.Vector3(0, -1.5, 0)), 0x886644, 10, 0.05, 0.15, 300);
            }

            // Handle dashing movement
            if (playerState.isDashing) {
                playerState.dashTime -= dt;
                const dashSpeed = 0.15; // Very fast dash
                worldMoveX = playerState.dashDir.x;
                worldMoveZ = playerState.dashDir.z;
                speed = dashSpeed;

                // Trail particles during dash
                if (Math.random() < 0.5) {
                    createParticles(playerState.position.clone(), 0x88ccff, 3, 0.02, 0.08, 150);
                }

                if (playerState.dashTime <= 0) {
                    playerState.isDashing = false;
                }
            }

            // Handle sliding movement
            if (playerState.isSliding) {
                playerState.slideTime -= dt;
                // Slide starts fast and slows down
                const slideProgress = 1 - (playerState.slideTime / 400);
                const slideSpeed = 0.08 * (1 - slideProgress * 0.7); // Decelerating slide
                worldMoveX = playerState.slideDir.x;
                worldMoveZ = playerState.slideDir.z;
                speed = slideSpeed;

                // Dust particles during slide
                if (Math.random() < 0.4) {
                    const dustPos = playerState.position.clone();
                    dustPos.y -= 1.5;
                    createParticles(dustPos, 0x886644, 2, 0.03, 0.1, 200);
                }

                if (playerState.slideTime <= 0) {
                    playerState.isSliding = false;
                }
            }

            const moveAmount = speed * dt;
            const newX = playerState.position.x + worldMoveX * moveAmount;
            const newZ = playerState.position.z + worldMoveZ * moveAmount;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            } else {
                if (!checkCollision(newX, playerState.position.z)) playerState.position.x = newX;
                else if (!checkCollision(playerState.position.x, newZ)) playerState.position.z = newZ;
            }
            
            playerState.position.x = Math.max(-120, Math.min(120, playerState.position.x));
            playerState.position.z = Math.max(-120, Math.min(120, playerState.position.z));
            
            // Gravity and terrain following
            const terrainY = getTerrainHeight(playerState.position.x, playerState.position.z);
            const groundY = terrainY + 1.7;
            
            playerState.velocity.y -= 0.004;
            playerState.position.y += playerState.velocity.y;
            
            if (playerState.position.y <= groundY) {
                playerState.position.y = groundY;
                playerState.velocity.y = 0;
                playerState.isGrounded = true;
                playerState.jumpsRemaining = playerState.maxJumps; // Reset double jump
                playerState.isWallRunning = false;
            }

            // Wall run cooldown
            if (playerState.wallRunCooldown > 0) playerState.wallRunCooldown -= dt;

            // Wall running detection and movement
            if (!playerState.isGrounded && !playerState.isWallRunning && playerState.wallRunCooldown <= 0) {
                // Check for walls to run on
                const wallCheckDist = 0.8;
                const directions = [
                    { x: 1, z: 0 },   // Right
                    { x: -1, z: 0 },  // Left
                    { x: 0, z: 1 },   // Forward
                    { x: 0, z: -1 }   // Back
                ];

                for (const dir of directions) {
                    const checkX = playerState.position.x + dir.x * wallCheckDist;
                    const checkZ = playerState.position.z + dir.z * wallCheckDist;

                    if (checkCollision(checkX, checkZ) && playerState.velocity.y < 0.05) {
                        // Found a wall! Start wall running
                        playerState.isWallRunning = true;
                        playerState.wallRunTime = 1500; // 1.5 seconds max wall run
                        playerState.wallNormal.set(-dir.x, 0, -dir.z); // Normal points away from wall

                        // Wall run direction is perpendicular to wall normal (along the wall)
                        // Use player's current movement to determine direction
                        const moveDir = new THREE.Vector3(worldMoveX, 0, worldMoveZ);
                        if (moveDir.length() > 0.1) {
                            // Project movement onto wall plane
                            const dot = moveDir.dot(playerState.wallNormal);
                            playerState.wallRunDir.copy(moveDir).sub(playerState.wallNormal.clone().multiplyScalar(dot)).normalize();
                        } else {
                            // Default to forward along wall
                            playerState.wallRunDir.set(-dir.z, 0, dir.x);
                        }

                        SFX.swordHit(); // Wall contact sound
                        break;
                    }
                }
            }

            // Handle wall running movement
            if (playerState.isWallRunning) {
                playerState.wallRunTime -= dt;

                // Slow fall during wall run
                playerState.velocity.y = -0.002;

                // Move along wall
                const wallSpeed = 0.04;
                const wallMoveX = playerState.position.x + playerState.wallRunDir.x * wallSpeed * dt;
                const wallMoveZ = playerState.position.z + playerState.wallRunDir.z * wallSpeed * dt;

                // Check if still next to wall
                const stillOnWall = checkCollision(
                    playerState.position.x - playerState.wallNormal.x * 0.8,
                    playerState.position.z - playerState.wallNormal.z * 0.8
                );

                if (stillOnWall && playerState.wallRunTime > 0) {
                    playerState.position.x = wallMoveX;
                    playerState.position.z = wallMoveZ;

                    // Wall run particles
                    if (Math.random() < 0.3) {
                        const particlePos = playerState.position.clone();
                        particlePos.x -= playerState.wallNormal.x * 0.5;
                        particlePos.z -= playerState.wallNormal.z * 0.5;
                        particlePos.y -= 1;
                        createParticles(particlePos, 0x888888, 2, 0.03, 0.08, 150);
                    }
                } else {
                    // Fell off wall
                    playerState.isWallRunning = false;
                    playerState.wallRunCooldown = 200;
                }
            }

            if (deviceMode === 'computer' && keys['Space']) { jump(); keys['Space'] = false; }
            
            camera.position.copy(playerState.position);

            // Camera effects for dash/slide/wallrun
            if (playerState.isDashing) {
                // Slight FOV increase during dash for speed effect
                camera.fov = 80;
                camera.updateProjectionMatrix();
            } else if (playerState.isSliding) {
                // Lower camera during slide
                camera.position.y -= 0.8;
                camera.fov = 78;
                camera.updateProjectionMatrix();
            } else if (playerState.isWallRunning) {
                // Tilt camera during wall run
                camera.fov = 78;
                camera.updateProjectionMatrix();
            } else if (camera.fov !== 75) {
                // Reset FOV
                camera.fov = 75;
                camera.updateProjectionMatrix();
            }

            // Camera tilt for wall running
            if (playerState.isWallRunning) {
                // Calculate tilt direction based on wall normal
                const tiltAmount = 0.15; // radians
                const rightDir = new THREE.Vector3(
                    Math.cos(playerState.rotation.y - Math.PI/2),
                    0,
                    Math.sin(playerState.rotation.y - Math.PI/2)
                );
                const tiltDir = rightDir.dot(playerState.wallNormal);
                camera.rotation.z = tiltDir * tiltAmount;
            } else {
                // Smoothly reset tilt
                camera.rotation.z *= 0.85;
                if (Math.abs(camera.rotation.z) < 0.01) camera.rotation.z = 0;
            }

            camera.rotation.order = 'YXZ';
            camera.rotation.y = playerState.rotation.y;
            camera.rotation.x = playerState.rotation.x;

            if (player) player.position.copy(playerState.position);
            
            // Update weapon position and animation based on weapon type
            if (swordMesh) {
                if (swordSwinging) {
                    swordSwingTime += dt;

                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    const right = new THREE.Vector3();
                    right.crossVectors(camera.up, dir).normalize();

                    // Different animation durations and styles per weapon type
                    let swingDuration, progress;

                    switch (currentWeaponAnim) {
                        case 'slash': // Horizontal arc (swords, katanas)
                            swingDuration = 300;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const slashAngle = Math.sin(progress * Math.PI) * 1.5;
                            const slashOffset = 0.4 - progress * 0.8;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.5));
                            swordMesh.position.add(right.clone().multiplyScalar(slashOffset));
                            swordMesh.position.y -= 0.3;
                            swordMesh.rotation.set(
                                camera.rotation.x - 0.5 + slashAngle * 0.3,
                                camera.rotation.y + slashAngle,
                                -0.3 + slashAngle * 0.5
                            );
                            break;

                        case 'thrust': // Forward stab (spears, daggers)
                            swingDuration = 250;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const thrustDist = Math.sin(progress * Math.PI) * 0.8;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.3 + thrustDist));
                            swordMesh.position.add(right.clone().multiplyScalar(0.15));
                            swordMesh.position.y -= 0.25;
                            swordMesh.rotation.set(
                                camera.rotation.x - 1.2,
                                camera.rotation.y,
                                0
                            );
                            break;

                        case 'smash': // Overhead smash (hammers, axes)
                            swingDuration = 450;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const smashAngle = progress < 0.4 ?
                                (progress / 0.4) * -1.5 : // Wind up
                                -1.5 + ((progress - 0.4) / 0.6) * 3.0; // Smash down
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.4));
                            swordMesh.position.add(right.clone().multiplyScalar(0.2));
                            swordMesh.position.y -= 0.1 + (progress > 0.4 ? (progress - 0.4) * 0.5 : 0);
                            swordMesh.rotation.set(
                                camera.rotation.x + smashAngle,
                                camera.rotation.y,
                                -0.2
                            );
                            break;

                        case 'rapid': // Fast multi-hit (claws, nunchucks)
                            swingDuration = 200;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const rapidAngle = Math.sin(progress * Math.PI * 3) * 0.8;
                            const rapidSide = Math.cos(progress * Math.PI * 3) * 0.3;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.5));
                            swordMesh.position.add(right.clone().multiplyScalar(rapidSide));
                            swordMesh.position.y -= 0.3 + rapidAngle * 0.1;
                            swordMesh.rotation.set(
                                camera.rotation.x - 0.3 + rapidAngle * 0.2,
                                camera.rotation.y + rapidAngle,
                                rapidAngle * 0.3
                            );
                            break;

                        case 'spin': // Spinning attack (flail, chainsaw)
                            swingDuration = 400;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const spinAngle = progress * Math.PI * 2;
                            const spinRadius = 0.4;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.4));
                            swordMesh.position.x += Math.cos(spinAngle) * spinRadius;
                            swordMesh.position.z += Math.sin(spinAngle) * spinRadius;
                            swordMesh.position.y -= 0.3;
                            swordMesh.rotation.set(
                                camera.rotation.x,
                                camera.rotation.y + spinAngle,
                                Math.sin(spinAngle) * 0.5
                            );
                            break;

                        case 'punch': // Punch forward (gauntlet)
                            swingDuration = 200;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const punchDist = Math.sin(progress * Math.PI) * 0.6;
                            const punchTwist = Math.sin(progress * Math.PI) * 0.5;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.3 + punchDist));
                            swordMesh.position.add(right.clone().multiplyScalar(0.2 - progress * 0.1));
                            swordMesh.position.y -= 0.35;
                            swordMesh.rotation.set(
                                camera.rotation.x - 1.0,
                                camera.rotation.y + punchTwist,
                                punchTwist
                            );
                            break;

                        case 'whip': // Whip crack (whip)
                            swingDuration = 350;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const whipAngle = progress < 0.3 ?
                                (progress / 0.3) * -0.8 : // Wind back
                                -0.8 + ((progress - 0.3) / 0.7) * 2.5; // Crack forward
                            const whipDist = progress > 0.3 ? ((progress - 0.3) / 0.7) * 0.8 : 0;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.3 + whipDist));
                            swordMesh.position.add(right.clone().multiplyScalar(0.25));
                            swordMesh.position.y -= 0.2;
                            swordMesh.rotation.set(
                                camera.rotation.x + whipAngle,
                                camera.rotation.y,
                                -0.3
                            );
                            break;

                        default: // Default slash
                            swingDuration = 300;
                            progress = Math.min(swordSwingTime / swingDuration, 1);
                            const defAngle = Math.sin(progress * Math.PI) * 1.5;
                            swordMesh.position.copy(camera.position);
                            swordMesh.position.add(dir.clone().multiplyScalar(0.5));
                            swordMesh.position.add(right.clone().multiplyScalar(0.4 - progress * 0.6));
                            swordMesh.position.y -= 0.3;
                            swordMesh.rotation.set(
                                camera.rotation.x - 0.5 + defAngle * 0.3,
                                camera.rotation.y + defAngle,
                                -0.3 + defAngle * 0.5
                            );
                    }

                    if (progress >= 1) {
                        swordSwinging = false;
                        swordMesh.visible = false;
                    }
                }
            }
        }
        
        // Enemy projectiles array
        let enemyProjectiles = [];

        function updateEnemies(dt) {
            enemies.forEach((e, idx) => {
                if (!e.mesh || e.dying) return;

                const toPlayer = playerState.position.clone().sub(e.mesh.position);
                toPlayer.y = 0;
                const dist = toPlayer.length();
                toPlayer.normalize();

                e.mesh.lookAt(new THREE.Vector3(playerState.position.x, e.mesh.position.y, playerState.position.z));

                // Initialize ability cooldown if not set
                if (e.abilityCooldown === undefined) e.abilityCooldown = 2000 + Math.random() * 3000;

                let isMoving = false;
                let useAbility = false;

                // ============================================
                // ENEMY ABILITY SYSTEM
                // ============================================
                e.abilityCooldown -= dt;

                if (e.abilityCooldown <= 0 && e.ability) {
                    useAbility = true;
                    e.abilityCooldown = 4000 + Math.random() * 3000; // Reset cooldown

                    switch (e.ability) {
                        case 'fireball':
                            // Mage shoots fireball at player
                            if (dist < 15 && dist > 3) {
                                const firePos = e.mesh.position.clone();
                                firePos.y += 1.2;
                                const fireDir = toPlayer.clone();
                                fireDir.y = (playerState.position.y - firePos.y) / dist;
                                fireDir.normalize();

                                // Create fireball mesh
                                const fbGeo = new THREE.SphereGeometry(0.2, 8, 8);
                                const fbMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                                const fireball = new THREE.Mesh(fbGeo, fbMat);
                                fireball.position.copy(firePos);

                                // Add glow
                                const glowGeo = new THREE.SphereGeometry(0.35, 8, 8);
                                const glowMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.4 });
                                fireball.add(new THREE.Mesh(glowGeo, glowMat));

                                scene.add(fireball);
                                enemyProjectiles.push({
                                    mesh: fireball,
                                    direction: fireDir,
                                    speed: 0.012,
                                    damage: e.damage * 1.5,
                                    life: 3000,
                                    type: 'fireball'
                                });

                                SFX.fireball();
                                createParticles(firePos, 0xff4400, 10, 0.05, 0.08, 300);
                            }
                            break;

                        case 'teleport':
                            // Assassin teleports behind player
                            if (dist < 12 && dist > 3) {
                                const behindPlayer = playerState.position.clone();
                                const playerDir = new THREE.Vector3();
                                camera.getWorldDirection(playerDir);
                                behindPlayer.sub(playerDir.multiplyScalar(2));
                                behindPlayer.y = getTerrainHeight(behindPlayer.x, behindPlayer.z) + 0.5;

                                // Teleport particles at old position
                                createParticles(e.mesh.position.clone(), 0x00ffff, 20, 0.1, 0.1, 400);
                                SFX.magic();

                                // Move enemy
                                e.mesh.position.copy(behindPlayer);

                                // Teleport particles at new position
                                createParticles(behindPlayer, 0x00ffff, 20, 0.1, 0.1, 400);
                            }
                            break;

                        case 'charge':
                            // Brute charges at player
                            if (dist < 10 && dist > 4) {
                                e.charging = true;
                                e.chargeDir = toPlayer.clone();
                                e.chargeTime = 800;
                                SFX.dash();
                                createParticles(e.mesh.position.clone(), 0xff2200, 15, 0.08, 0.1, 300);
                            }
                            break;

                        case 'shoot':
                            // Archer shoots arrow
                            if (dist < 18 && dist > 5) {
                                const arrowPos = e.mesh.position.clone();
                                arrowPos.y += 1.1;
                                const arrowDir = toPlayer.clone();
                                arrowDir.y = (playerState.position.y - arrowPos.y) / dist * 0.5;
                                arrowDir.normalize();

                                const arrowGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 6);
                                const arrowMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
                                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                                arrow.position.copy(arrowPos);
                                arrow.lookAt(playerState.position);
                                arrow.rotateX(Math.PI / 2);

                                scene.add(arrow);
                                enemyProjectiles.push({
                                    mesh: arrow,
                                    direction: arrowDir,
                                    speed: 0.02,
                                    damage: e.damage,
                                    life: 2000,
                                    type: 'arrow'
                                });

                                SFX.bowShoot();
                            }
                            break;

                        case 'freeze':
                            // Frost Mage shoots ice bolt
                            if (dist < 12 && dist > 3) {
                                const icePos = e.mesh.position.clone();
                                icePos.y += 1.2;
                                const iceDir = toPlayer.clone();
                                iceDir.normalize();

                                const iceGeo = new THREE.OctahedronGeometry(0.15, 0);
                                const iceMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                                const iceBolt = new THREE.Mesh(iceGeo, iceMat);
                                iceBolt.position.copy(icePos);

                                scene.add(iceBolt);
                                enemyProjectiles.push({
                                    mesh: iceBolt,
                                    direction: iceDir,
                                    speed: 0.015,
                                    damage: e.damage,
                                    life: 2500,
                                    type: 'ice',
                                    effect: 'slow'
                                });

                                SFX.magic();
                                createParticles(icePos, 0x00ffff, 8, 0.04, 0.06, 200);
                            }
                            break;

                        case 'heal':
                            // Paladin heals nearby enemies
                            enemies.forEach(other => {
                                if (other === e || !other.mesh || other.dying) return;
                                const healDist = e.mesh.position.distanceTo(other.mesh.position);
                                if (healDist < 5) {
                                    other.health = Math.min(other.maxHealth, other.health + other.maxHealth * 0.2);
                                    createParticles(other.mesh.position.clone(), 0xffff00, 10, 0.05, 0.08, 400);
                                }
                            });
                            SFX.heal();
                            createParticles(e.mesh.position.clone(), 0xffff00, 20, 0.08, 0.1, 500);
                            break;

                        case 'rage':
                            // Berserker enters rage mode
                            e.rageMode = true;
                            e.rageTime = 5000;
                            e.speed *= 1.5;
                            e.damage *= 1.5;
                            SFX.bossRoar();
                            createParticles(e.mesh.position.clone(), 0xff0000, 25, 0.1, 0.12, 600);
                            break;

                        case 'phase':
                            // Shadow phases through attacks briefly
                            e.phasing = true;
                            e.phaseTime = 2000;
                            e.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                            SFX.magic();
                            break;

                        case 'stomp':
                            // Golem ground stomp damages player if close
                            if (dist < 4) {
                                damagePlayer(e.damage * 2);
                                SFX.explosion();
                                createParticles(e.mesh.position.clone(), 0x8B4513, 30, 0.15, 0.15, 500);
                                // Screen shake effect
                                camera.position.x += (Math.random() - 0.5) * 0.2;
                                camera.position.y += (Math.random() - 0.5) * 0.1;
                            }
                            break;

                        case 'lifesteal':
                            // Vampire heals on hit (handled in melee attack)
                            e.lifestealActive = true;
                            e.lifestealTime = 3000;
                            createParticles(e.mesh.position.clone(), 0xff0000, 15, 0.06, 0.08, 400);
                            break;

                        case 'summon':
                            // Necromancer summons a weak minion
                            if (enemies.length < 20) {
                                const summonPos = e.mesh.position.clone();
                                summonPos.x += (Math.random() - 0.5) * 3;
                                summonPos.z += (Math.random() - 0.5) * 3;
                                createParticles(summonPos, 0x00ff00, 20, 0.1, 0.1, 500);
                                SFX.magic();
                                // Spawn a weak grunt
                                setTimeout(() => spawnEnemy(), 500);
                            }
                            break;
                    }
                }

                // Handle charging state
                if (e.charging && e.chargeTime > 0) {
                    e.chargeTime -= dt;
                    const chargeX = e.mesh.position.x + e.chargeDir.x * e.speed * dt * 4;
                    const chargeZ = e.mesh.position.z + e.chargeDir.z * e.speed * dt * 4;

                    // Stop charge if hitting wall
                    if (checkCollision(chargeX, chargeZ)) {
                        e.charging = false;
                        createParticles(e.mesh.position.clone(), 0x888888, 8, 0.1, 0.15, 200);
                        SFX.swordHit();
                    } else {
                        e.mesh.position.x = chargeX;
                        e.mesh.position.z = chargeZ;
                        isMoving = true;
                    }
                    if (e.chargeTime <= 0) e.charging = false;
                }

                // Handle rage timeout
                if (e.rageMode && e.rageTime !== undefined) {
                    e.rageTime -= dt;
                    if (e.rageTime <= 0) {
                        e.rageMode = false;
                        e.speed /= 1.5;
                        e.damage /= 1.5;
                    }
                }

                // Handle phase timeout
                if (e.phasing && e.phaseTime !== undefined) {
                    e.phaseTime -= dt;
                    if (e.phaseTime <= 0) {
                        e.phasing = false;
                        e.mesh.traverse(child => {
                            if (child.material) {
                                child.material.opacity = 1;
                            }
                        });
                    }
                }

                // Normal movement (if not using special ability)
                if (dist > 1.3 && !e.charging) {
                    // Pathfinding - check if stuck
                    if (e.lastPos) {
                        const movedDist = Math.sqrt(
                            Math.pow(e.mesh.position.x - e.lastPos.x, 2) +
                            Math.pow(e.mesh.position.z - e.lastPos.z, 2)
                        );
                        if (movedDist < 0.01) {
                            e.stuckTime = (e.stuckTime || 0) + dt;
                        } else {
                            e.stuckTime = 0;
                        }
                        e.lastPos.set(e.mesh.position.x, 0, e.mesh.position.z);
                    }

                    let moveX = toPlayer.x;
                    let moveZ = toPlayer.z;

                    // If stuck for too long, try alternate routes
                    if (e.stuckTime > 500) {
                        // Try going around obstacle
                        const perpAngle = Math.atan2(toPlayer.z, toPlayer.x) + (Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2);
                        moveX = Math.cos(perpAngle);
                        moveZ = Math.sin(perpAngle);

                        // Reset stuck time occasionally to retry direct path
                        if (e.stuckTime > 2000) {
                            e.stuckTime = 0;
                        }
                    }

                    let newX = e.mesh.position.x + moveX * e.speed * dt;
                    let newZ = e.mesh.position.z + moveZ * e.speed * dt;

                    let canMove = true;

                    // Check wall collision first
                    if (checkCollision(newX, newZ)) {
                        canMove = false;
                        // Try sliding along walls
                        if (!checkCollision(newX, e.mesh.position.z)) {
                            e.mesh.position.x = newX;
                            isMoving = true;
                        } else if (!checkCollision(e.mesh.position.x, newZ)) {
                            e.mesh.position.z = newZ;
                            isMoving = true;
                        } else {
                            // Completely blocked - try random direction
                            e.stuckTime += dt * 2;
                        }
                    }

                    // Check other enemy collision
                    if (canMove) {
                        enemies.forEach((other, otherIdx) => {
                            if (idx === otherIdx || !other.mesh) return;
                            const dx = newX - other.mesh.position.x;
                            const dz = newZ - other.mesh.position.z;
                            const distToOther = Math.sqrt(dx * dx + dz * dz);

                            if (distToOther < 1.0) {
                                canMove = false;
                                if (distToOther > 0.1) {
                                    e.mesh.position.x += (dx / distToOther) * 0.02;
                                    e.mesh.position.z += (dz / distToOther) * 0.02;
                                }
                            }
                        });
                    }

                    if (canMove) {
                        e.mesh.position.x = newX;
                        e.mesh.position.z = newZ;
                        isMoving = true;
                    }
                }

                // Update Y position to terrain height
                const terrainY = getTerrainHeight(e.mesh.position.x, e.mesh.position.z);
                const scale = e.mesh.scale.x || 1;
                e.mesh.position.y = terrainY + 0.4 + (0.25 * scale);

                // Animate arms and legs
                if (isMoving && e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    e.animTime += dt * 0.012;
                    const swing = Math.sin(e.animTime) * 0.6;
                    e.leftArm.rotation.x = swing;
                    e.rightArm.rotation.x = -swing;
                    e.leftLeg.rotation.x = -swing * 0.8;
                    e.rightLeg.rotation.x = swing * 0.8;
                } else if (e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    e.leftArm.rotation.x *= 0.9;
                    e.rightArm.rotation.x *= 0.9;
                    e.leftLeg.rotation.x *= 0.9;
                    e.rightLeg.rotation.x *= 0.9;
                }

                // Update health bar
                if (e.healthBar && e.healthBarFill) {
                    // Make health bar face camera
                    e.healthBar.lookAt(camera.position);

                    // Update health bar fill
                    const healthPercent = e.health / e.maxHealth;
                    e.healthBarFill.scale.x = Math.max(0.01, healthPercent);
                    e.healthBarFill.position.x = -0.38 * (1 - healthPercent);

                    // Color based on health (green -> yellow -> red)
                    if (healthPercent > 0.6) {
                        e.healthBarFill.material.color.setHex(0x44ff44);
                    } else if (healthPercent > 0.3) {
                        e.healthBarFill.material.color.setHex(0xffff00);
                    } else {
                        e.healthBarFill.material.color.setHex(0xff4444);
                    }
                }

                // Melee attack
                if (dist < 1.8 && e.attackCooldown <= 0 && !e.phasing) {
                    damagePlayer(e.damage);
                    e.attackCooldown = 1500;

                    // Vampire lifesteal
                    if (e.lifestealActive) {
                        e.health = Math.min(e.maxHealth, e.health + e.damage * 0.5);
                        createParticles(e.mesh.position.clone(), 0xff0000, 8, 0.04, 0.06, 300);
                    }
                }

                e.attackCooldown -= dt;
                if (e.lifestealTime !== undefined) {
                    e.lifestealTime -= dt;
                    if (e.lifestealTime <= 0) e.lifestealActive = false;
                }
            });
        }

        // Update enemy projectiles
        function updateEnemyProjectiles(dt) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.mesh.position.add(p.direction.clone().multiplyScalar(p.speed * dt));
                p.life -= dt;

                // Trail particles
                if (p.type === 'fireball' && Math.random() < 0.3) {
                    createParticles(p.mesh.position.clone(), 0xff4400, 2, 0.02, 0.05, 200);
                } else if (p.type === 'ice' && Math.random() < 0.2) {
                    createParticles(p.mesh.position.clone(), 0x00ffff, 1, 0.02, 0.04, 150);
                }

                // Check wall collision - destroy projectile on impact
                if (checkCollision(p.mesh.position.x, p.mesh.position.z)) {
                    if (p.type === 'fireball') {
                        createParticles(p.mesh.position.clone(), 0xff4400, 10, 0.08, 0.1, 200);
                        SFX.explosion();
                    } else if (p.type === 'ice') {
                        createParticles(p.mesh.position.clone(), 0x00ffff, 8, 0.06, 0.08, 150);
                    } else {
                        createParticles(p.mesh.position.clone(), 0x888888, 5, 0.04, 0.06, 100);
                    }
                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                // Check hit player
                const distToPlayer = p.mesh.position.distanceTo(playerState.position);
                if (distToPlayer < 0.8) {
                    damagePlayer(p.damage);
                    SFX.playerHit();

                    if (p.type === 'fireball') {
                        createParticles(p.mesh.position.clone(), 0xff4400, 15, 0.1, 0.1, 300);
                        SFX.explosion();
                    } else if (p.type === 'ice') {
                        createParticles(p.mesh.position.clone(), 0x00ffff, 12, 0.08, 0.08, 250);
                        // Slow player briefly
                        playerState.slowed = true;
                        playerState.slowTime = 2000;
                    }

                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                // Remove expired projectiles
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i, 1);
                }
            }
        }
        
        function updateBoss(dt) {
            if (!boss || !boss.mesh) return;

            const toPlayer = playerState.position.clone().sub(boss.mesh.position);
            toPlayer.y = 0;
            const dist = toPlayer.length();
            toPlayer.normalize();

            boss.mesh.lookAt(new THREE.Vector3(playerState.position.x, boss.mesh.position.y, playerState.position.z));

            let isMoving = false;

            // Pathfinding for boss - detect if stuck
            if (!boss.lastPos) boss.lastPos = boss.mesh.position.clone();
            if (!boss.stuckTime) boss.stuckTime = 0;

            const movedDist = Math.sqrt(
                Math.pow(boss.mesh.position.x - boss.lastPos.x, 2) +
                Math.pow(boss.mesh.position.z - boss.lastPos.z, 2)
            );

            if (movedDist < 0.01 && dist > 3) {
                boss.stuckTime += dt;
            } else {
                boss.stuckTime = 0;
            }
            boss.lastPos.copy(boss.mesh.position);

            if (dist > 2) {
                let moveX = toPlayer.x;
                let moveZ = toPlayer.z;

                // If stuck, try going around
                if (boss.stuckTime > 500) {
                    const perpAngle = Math.atan2(toPlayer.z, toPlayer.x) + (Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2);
                    moveX = Math.cos(perpAngle);
                    moveZ = Math.sin(perpAngle);
                    if (boss.stuckTime > 2000) boss.stuckTime = 0;
                }

                const newX = boss.mesh.position.x + moveX * boss.speed * dt;
                const newZ = boss.mesh.position.z + moveZ * boss.speed * dt;

                // Check wall collision for boss
                if (!checkCollision(newX, newZ)) {
                    boss.mesh.position.x = newX;
                    boss.mesh.position.z = newZ;
                    isMoving = true;
                } else {
                    // Try sliding along walls
                    if (!checkCollision(newX, boss.mesh.position.z)) {
                        boss.mesh.position.x = newX;
                        isMoving = true;
                    } else if (!checkCollision(boss.mesh.position.x, newZ)) {
                        boss.mesh.position.z = newZ;
                        isMoving = true;
                    } else {
                        boss.stuckTime += dt * 2;
                    }
                }
            }

            // Update Y position to terrain height (with offset to prevent leg clipping)
            const terrainY = getTerrainHeight(boss.mesh.position.x, boss.mesh.position.z);

            // Dragon boss hovers higher
            if (boss.type === 'dragon') {
                boss.mesh.position.y = terrainY + 1.5 + Math.sin(boss.animTime * 2) * 0.3;
            } else {
                boss.mesh.position.y = terrainY + 0.25;
            }

            // Animate based on boss type
            boss.animTime += dt * 0.008;

            if (boss.type === 'dragon' && boss.leftWing && boss.rightWing) {
                // Dragon wing flapping animation
                const wingFlap = Math.sin(boss.animTime * 3) * 0.4;
                boss.leftWing.rotation.z = 0.5 + wingFlap;
                boss.rightWing.rotation.z = -0.5 - wingFlap;

                // Subtle body bob
                boss.mesh.rotation.x = Math.sin(boss.animTime * 2) * 0.05;
            } else if (boss.type === 'demon' && isMoving && boss.leftArm && boss.rightArm && boss.leftLeg && boss.rightLeg) {
                // Demon walking animation
                const swing = Math.sin(boss.animTime) * 0.5;
                boss.leftArm.rotation.x = swing;
                boss.rightArm.rotation.x = -swing;
                boss.leftLeg.rotation.x = -swing * 0.7;
                boss.rightLeg.rotation.x = swing * 0.7;
            }

            // Attack range varies by boss type
            const attackRange = boss.type === 'dragon' ? 4 : 3;
            if (dist < attackRange && boss.attackCooldown <= 0) {
                damagePlayer(boss.damage);
                boss.attackCooldown = boss.type === 'dragon' ? 1500 : 2000;

                // Dragon fire breath particles on attack
                if (boss.type === 'dragon') {
                    const firePos = boss.mesh.position.clone();
                    firePos.y += 2;
                    createParticles(firePos, 0xff4400, 20, 0.15, 0.15, 400, 1.5);
                    createParticles(firePos, 0xffaa00, 15, 0.12, 0.1, 300, 1.2);
                }
            }

            boss.attackCooldown -= dt;
        }
        
        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.position.add(p.direction.clone().multiplyScalar(p.speed * dt / 16));
                p.life -= dt;

                // Create particle trail
                p.trailTimer = (p.trailTimer || 0) + dt;
                if (p.trailTimer > 30 && p.color) {
                    p.trailTimer = 0;
                    createProjectileTrail(p.mesh.position.clone(), p.color);
                }

                let hitSomething = false;

                enemies.forEach(e => {
                    if (!e.mesh || hitSomething) return;
                    if (p.mesh.position.distanceTo(e.mesh.position) < 0.9) {
                        damageEnemy(e, p.damage, false);
                        // Explosion particles on impact
                        const impactPos = p.mesh.position.clone();
                        impactPos.y += 0.5;
                        createExplosionParticles(impactPos, p.color || 0xff4400, 0xffaa00);
                        p.life = 0;
                        hitSomething = true;
                    }
                });

                if (boss && boss.mesh && p.mesh.position.distanceTo(boss.mesh.position) < 1.4) {
                    damageBoss(p.damage, false);
                    // Big explosion on boss
                    const impactPos = p.mesh.position.clone();
                    createExplosionParticles(impactPos, p.color || 0xff0000, 0xff6600);
                    p.life = 0;
                    hitSomething = true;
                }

                if (p.life <= 0) {
                    // Fizzle particles if it didn't hit anything
                    if (!hitSomething) {
                        createParticles(p.mesh.position.clone(), p.color || 0xaaaaaa, 5, 0.02, 0.04, 200, 0.5);
                    }
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function updateCoins(dt) {
            const collectRange = settings.autoCollectCoins ? 2.5 : 1;
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                
                c.mesh.rotation.z += 0.02;
                const baseY = c.baseY || 0.5;
                c.mesh.position.y = baseY + Math.sin(Date.now() * 0.003 + c.bobOffset) * 0.08;
                
                const dx = c.mesh.position.x - playerState.position.x;
                const dz = c.mesh.position.z - playerState.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < collectRange) {
                    inventory.coins += c.value;
                    SFX.coinPickup(); // Play coin sound

                    const div = document.createElement('div');
                    div.className = 'coin-pickup';
                    div.textContent = '+' + c.value + ' üí∞';
                    div.style.left = '50%';
                    div.style.top = '35%';
                    document.body.appendChild(div);
                    setTimeout(() => div.remove(), 1000);

                    scene.remove(c.mesh);
                    coins.splice(i, 1);
                    updateHUD();
                }
            }
        }
        
        function updateCooldowns(dt) {
            for (const id in itemCooldowns) {
                if (itemCooldowns[id] > 0) itemCooldowns[id] -= dt;
            }
            
            if (playerState.energy < playerState.maxEnergy) {
                playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + dt * 0.002);
            }
        }
        
        let lastTime = 0;
        let lastSaveTime = 0;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);

            const dt = Math.min(timestamp - lastTime, 50);
            lastTime = timestamp;

            if (!gameRunning) {
                renderer.render(scene, camera);
                return;
            }

            updatePlayer(dt);
            updateEnemies(dt);
            updateBoss(dt);
            updateProjectiles(dt);
            updateEnemyProjectiles(dt);
            updateCoins(dt);
            updateCooldowns(dt);
            updateParticles(dt);
            updateHUD();
            updateMinimap();
            updateHitboxVisualization(); // Show hitboxes if enabled
            updateProceduralGeneration(); // Generate houses and lakes as player explores

            // Auto-save coins every 15 seconds
            if (timestamp - lastSaveTime > 15000) {
                lastSaveTime = timestamp;
                saveCoinsToCloud();
            }

            renderer.render(scene, camera);
        }
        
        function startGame() {
            initAudio(); // Initialize sound system
            initChat(); // Initialize chat system
            enterFullscreen();
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('coinsDisplay').style.display = 'block';
            document.getElementById('statsPanel').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hotbar').style.display = 'flex';
            document.getElementById('chatContainer').style.display = 'block';

            setupInput();

            if (deviceMode === 'mobile') {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                // Request pointer lock - if it fails, user can click canvas to lock
                renderer.domElement.requestPointerLock();
            }

            gameRunning = true;
            startWave();
            startBackgroundMusic(); // Start epic background music
        }

        function restartGame() {
            playerState.position.set(0, 1.7, 0);
            playerState.velocity.set(0, 0, 0);
            playerState.rotation = { x: 0, y: 0 };
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;
            playerState.score = 0;
            playerState.kills = 0;
            playerState.isGrounded = true;
            playerState.jumpsRemaining = playerState.maxJumps;
            playerState.isWallRunning = false;
            playerState.isDashing = false;
            playerState.isSliding = false;

            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            
            if (boss) { scene.remove(boss.mesh); boss = null; }
            document.getElementById('bossHealth').style.display = 'none';
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];

            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            coins.forEach(c => scene.remove(c.mesh));
            coins = [];

            itemCooldowns = {};
            currentWave = 1;
            waveInProgress = false;
            
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;
            startWave();
        }
        
        function backToMenu() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('coinsDisplay').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('hotbar').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
            saveCoinsToCloud(); // Save coins when returning to menu
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            if (boss) { scene.remove(boss.mesh); boss = null; }
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];
            coins.forEach(c => scene.remove(c.mesh));
            coins = [];
            
            currentWave = 1;
            waveInProgress = false;
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        init();
        checkPaymentSuccess(); // Check for successful Stripe payment
        gameLoop(0);
    </script>
</body>
</html>
